/*******************************************************************************

    Copyright 2012 Ben Wojtowicz

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

*******************************************************************************

    File: liblte_phy.cc

    Description: Contains all the implementations for the LTE Physical Layer
                 library.

    Revision History
    ----------    -------------    --------------------------------------------
    02/26/2012    Ben Wojtowicz    Created file.
    04/25/2012    Ben Wojtowicz    Added Turbo encode/decode and PDSCH decode
    05/06/2012    Ben Wojtowicz    Fixed bugs in find_pss_and_fine_timing and
                                   find_sss (thanks Joel!!)
    05/13/2012    Ben Wojtowicz    Fixed a bug with frame_start_idx going
                                   negative in find_sss (thanks again Joel!!)

*******************************************************************************/

/*******************************************************************************
                              INCLUDES
*******************************************************************************/

#include "liblte_phy.h"
#include <math.h>

/*******************************************************************************
                              DEFINES
*******************************************************************************/

#define N_SYMB_DL_NORMAL_CP 7
#define N_CP_L_ELSE         144
#define N_CP_L_0            160

/*******************************************************************************
                              TYPEDEFS
*******************************************************************************/


/*******************************************************************************
                              GLOBAL VARIABLES
*******************************************************************************/

// Control Format Indicator
uint8 CFI_BITS_1[32] = {0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1};
uint8 CFI_BITS_2[32] = {1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0};
uint8 CFI_BITS_3[32] = {1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1};
uint8 CFI_BITS_4[32] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

// Rate Matching
uint8 IC_PERM_CC[32] = { 1,17, 9,25, 5,21,13,29, 3,19,11,27, 7,23,15,31,
                         0,16, 8,24, 4,20,12,28, 2,18,10,26, 6,22,14,30};
uint8 IC_PERM_TC[32] = { 0,16, 8,24, 4,20,12,28, 2,18,10,26, 6,22,14,30,
                         1,17, 9,25, 5,21,13,29, 3,19,11,27, 7,23,15,31};

// Turbo Internal Interleaver from 3GPP TS 36.212 v10.1.0 table 5.1.3-3
#define TURBO_INT_K_TABLE_SIZE 188
uint32 TURBO_INT_K_TABLE[188] = {  40,  48,  56,  64,  72,  80,  88,  96, 104, 112,
                                  120, 128, 136, 144, 152, 160, 168, 176, 184, 192,
                                  200, 208, 216, 224, 232, 240, 248, 256, 264, 272,
                                  280, 288, 296, 304, 312, 320, 328, 336, 344, 352,
                                  360, 368, 376, 384, 392, 400, 408, 416, 424, 432,
                                  440, 448, 456, 464, 472, 480, 488, 496, 504, 512,
                                  528, 544, 560, 576, 592, 608, 624, 640, 656, 672,
                                  688, 704, 720, 736, 752, 768, 784, 800, 816, 832,
                                  848, 864, 880, 896, 912, 928, 944, 960, 976, 992,
                                 1008,1024,1056,1088,1120,1152,1184,1216,1248,1280,
                                 1312,1344,1376,1408,1440,1472,1504,1536,1568,1600,
                                 1632,1664,1696,1728,1760,1792,1824,1856,1888,1920,
                                 1952,1984,2016,2048,2112,2176,2240,2304,2368,2432,
                                 2496,2560,2624,2688,2752,2816,2880,2944,3008,3072,
                                 3136,3200,3264,3328,3392,3456,3520,3584,3648,3712,
                                 3776,3840,3904,3968,4032,4096,4160,4224,4288,4352,
                                 4416,4480,4544,4608,4672,4736,4800,4864,4928,4992,
                                 5056,5120,5184,5248,5312,5376,5440,5504,5568,5632,
                                 5696,5760,5824,5888,5952,6016,6080,6144};
uint32 TURBO_INT_F1_TABLE[188] = {  3,  7, 19,  7,  7, 11,  5, 11,  7, 41,103, 15,  9,
                                   17,  9, 21,101, 21, 57, 23, 13, 27, 11, 27, 85, 29,
                                   33, 15, 17, 33,103, 19, 19, 37, 19, 21, 21,115,193,
                                   21,133, 81, 45, 23,243,151,155, 25, 51, 47, 91, 29,
                                   29,247, 29, 89, 91,157, 55, 31, 17, 35,227, 65, 19,
                                   37, 41, 39,185, 43, 21,155, 79,139, 23,217, 25, 17,
                                  127, 25,239, 17,137,215, 29, 15,147, 29, 59, 65, 55,
                                   31, 17,171, 67, 35, 19, 39, 19,199, 21,211, 21, 43,
                                  149, 45, 49, 71, 13, 17, 25,183, 55,127, 27, 29, 29,
                                   57, 45, 31, 59,185,113, 31, 17,171,209,253,367,265,
                                  181, 39, 27,127,143, 43, 29, 45,157, 47, 13,111,443,
                                   51, 51,451,257, 57,313,271,179,331,363,375,127, 31,
                                   33, 43, 33,477, 35,233,357,337, 37, 71, 71, 37, 39,
                                  127, 39, 39, 31,113, 41,251, 43, 21, 43, 45, 45,161,
                                   89,323, 47, 23, 47,263};
uint32 TURBO_INT_F2_TABLE[188] = { 10, 12, 42, 16, 18, 20, 22, 24, 26, 84, 90, 32, 34,
                                  108, 38,120, 84, 44, 46, 48, 50, 52, 36, 56, 58, 60,
                                   62, 32,198, 68,210, 36, 74, 76, 78,120, 82, 84, 86,
                                   44, 90, 46, 94, 48, 98, 40,102, 52,106, 72,110,168,
                                  114, 58,118,180,122, 62, 84, 64, 66, 68,420, 96, 74,
                                   76,234, 80, 82,252, 86, 44,120, 92, 94, 48, 98, 80,
                                  102, 52,106, 48,110,112,114, 58,118, 60,122,124, 84,
                                   64, 66,204,140, 72, 74, 76, 78,240, 82,252, 86, 88,
                                   60, 92,846, 48, 28, 80,102,104,954, 96,110,112,114,
                                  116,354,120,610,124,420, 64, 66,136,420,216,444,456,
                                  468, 80,164,504,172, 88,300, 92,188, 96, 28,240,204,
                                  104,212,192,220,336,228,232,236,120,244,248,168, 64,
                                  130,264,134,408,138,280,142,480,146,444,120,152,462,
                                  234,158, 80, 96,902,166,336,170, 86,174,176,178,120,
                                  182,184,186, 94,190,480};

// Transport Block Size from 3GPP TS 36.213 v10.3.0 table 7.1.7.2.1-1
uint32 TBS_71721[27][110] = {{   16,   32,   56,   88,  120,  152,  176,  208,  224,  256,  288,
                                328,  344,  376,  392,  424,  456,  488,  504,  536,  568,  600,
                                616,  648,  680,  712,  744,  776,  776,  808,  840,  872,  904,
                                936,  968, 1000, 1032, 1032, 1064, 1096, 1128, 1160, 1192, 1224,
                               1256, 1256, 1288, 1320, 1352, 1384, 1416, 1416, 1480, 1480, 1544,
                               1544, 1608, 1608, 1608, 1672, 1672, 1736, 1736, 1800, 1800, 1800,
                               1864, 1864, 1928, 1928, 1992, 1992, 2024, 2088, 2088, 2088, 2152,
                               2152, 2216, 2216, 2280, 2280, 2280, 2344, 2344, 2408, 2408, 2472,
                               2472, 2536, 2536, 2536, 2600, 2600, 2664, 2664, 2728, 2728, 2728,
                               2792, 2792, 2856, 2856, 2856, 2984, 2984, 2984, 2984, 2984, 3112},
                             {   24,   56,   88,  144,  176,  208,  224,  256,  328,  344,  376,
                                424,  456,  488,  520,  568,  600,  632,  680,  712,  744,  776,
                                808,  872,  904,  936,  968, 1000, 1032, 1064, 1128, 1160, 1192,
                               1224, 1256, 1288, 1352, 1384, 1416, 1416, 1480, 1544, 1544, 1608,
                               1608, 1672, 1736, 1736, 1800, 1800, 1864, 1864, 1928, 1992, 1992,
                               2024, 2088, 2088, 2152, 2152, 2216, 2280, 2280, 2344, 2344, 2408,
                               2472, 2472, 2536, 2536, 2600, 2600, 2664, 2728, 2728, 2792, 2792,
                               2856, 2856, 2856, 2984, 2984, 2984, 3112, 3112, 3112, 3240, 3240,
                               3240, 3240, 3368, 3368, 3368, 3496, 3496, 3496, 3496, 3624, 3624,
                               3624, 3752, 3752, 3752, 3752, 3880, 3880, 3880, 4008, 4008, 4008},
                             {   32,   72,  144,  176,  208,  256,  296,  328,  376,  424,  472,
                                520,  568,  616,  648,  696,  744,  776,  840,  872,  936,  968,
                               1000, 1064, 1096, 1160, 1192, 1256, 1288, 1320, 1384, 1416, 1480,
                               1544, 1544, 1608, 1672, 1672, 1736, 1800, 1800, 1864, 1928, 1992,
                               2024, 2088, 2088, 2152, 2216, 2216, 2280, 2344, 2344, 2408, 2472,
                               2536, 2536, 2600, 2664, 2664, 2728, 2792, 2856, 2856, 2856, 2984,
                               2984, 3112, 3112, 3112, 3240, 3240, 3240, 3368, 3368, 3368, 3496,
                               3496, 3496, 3624, 3624, 3624, 3752, 3752, 3880, 3880, 3880, 4008,
                               4008, 4008, 4136, 4136, 4136, 4264, 4264, 4264, 4392, 4392, 4392,
                               4584, 4584, 4584, 4584, 4584, 4776, 4776, 4776, 4776, 4968, 4968},
                             {   40,  104,  176,  208,  256,  328,  392,  440,  504,  568,  616,
                                680,  744,  808,  872,  904,  968, 1032, 1096, 1160, 1224, 1256,
                               1320, 1384, 1416, 1480, 1544, 1608, 1672, 1736, 1800, 1864, 1928,
                               1992, 2024, 2088, 2152, 2216, 2280, 2344, 2408, 2472, 2536, 2536,
                               2600, 2664, 2728, 2792, 2856, 2856, 2984, 2984, 3112, 3112, 3240,
                               3240, 3368, 3368, 3496, 3496, 3624, 3624, 3624, 3752, 3752, 3880,
                               3880, 4008, 4008, 4136, 4136, 4264, 4264, 4392, 4392, 4392, 4584,
                               4584, 4584, 4776, 4776, 4776, 4776, 4968, 4968, 4968, 5160, 5160,
                               5160, 5352, 5352, 5352, 5352, 5544, 5544, 5544, 5736, 5736, 5736,
                               5736, 5992, 5992, 5992, 5992, 6200, 6200, 6200, 6200, 6456, 6456},
                             {   56,  120,  208,  256,  328,  408,  488,  552,  632,  696,  776,
                                840,  904, 1000, 1064, 1128, 1192, 1288, 1352, 1416, 1480, 1544,
                               1608, 1736, 1800, 1864, 1928, 1992, 2088, 2152, 2216, 2280, 2344,
                               2408, 2472, 2600, 2664, 2728, 2792, 2856, 2984, 2984, 3112, 3112,
                               3240, 3240, 3368, 3496, 3496, 3624, 3624, 3752, 3752, 3880, 4008,
                               4008, 4136, 4136, 4264, 4264, 4392, 4392, 4584, 4584, 4584, 4776,
                               4776, 4968, 4968, 4968, 5160, 5160, 5160, 5352, 5352, 5544, 5544,
                               5544, 5736, 5736, 5736, 5992, 5992, 5992, 5992, 6200, 6200, 6200,
                               6456, 6456, 6456, 6456, 6712, 6712, 6712, 6968, 6968, 6968, 6968,
                               7224, 7224, 7224, 7480, 7480, 7480, 7480, 7736, 7736, 7736, 7992},
                             {   72,  144,  224,  328,  424,  504,  600,  680,  776,  872,  968,
                               1032, 1128, 1224, 1320, 1384, 1480, 1544, 1672, 1736, 1864, 1928,
                               2024, 2088, 2216, 2280, 2344, 2472, 2536, 2664, 2728, 2792, 2856,
                               2984, 3112, 3112, 3240, 3368, 3496, 3496, 3624, 3752, 3752, 3880,
                               4008, 4008, 4136, 4264, 4392, 4392, 4584, 4584, 4776, 4776, 4776,
                               4968, 4968, 5160, 5160, 5352, 5352, 5544, 5544, 5736, 5736, 5736,
                               5992, 5992, 5992, 6200, 6200, 6200, 6456, 6456, 6712, 6712, 6712,
                               6968, 6968, 6968, 7224, 7224, 7224, 7480, 7480, 7480, 7736, 7736,
                               7736, 7992, 7992, 7992, 8248, 8248, 8248, 8504, 8504, 8760, 8760,
                               8760, 8760, 9144, 9144, 9144, 9144, 9528, 9528, 9528, 9528, 9528},
                             {  328,  176,  256,  392,  504,  600,  712,  808,  936, 1032, 1128,
                               1224, 1352, 1480, 1544, 1672, 1736, 1864, 1992, 2088, 2216, 2280,
                               2408, 2472, 2600, 2728, 2792, 2984, 2984, 3112, 3240, 3368, 3496,
                               3496, 3624, 3752, 3880, 4008, 4136, 4136, 4264, 4392, 4584, 4584,
                               4776, 4776, 4968, 4968, 5160, 5160, 5352, 5352, 5544, 5736, 5736,
                               5992, 5992, 5992, 6200, 6200, 6456, 6456, 6456, 6712, 6712, 6968,
                               6968, 6968, 7224, 7224, 7480, 7480, 7736, 7736, 7736, 7992, 7992,
                               8248, 8248, 8248, 8504, 8504, 8760, 8760, 8760, 9144, 9144, 9144,
                               9144, 9528, 9528, 9528, 9528, 9912, 9912, 9912,10296,10296,10296,
                              10296,10680,10680,10680,10680,11064,11064,11064,11448,11448,11448},
                             {  104,  224,  328,  472,  584,  712,  840,  968, 1096, 1224, 1320,
                               1480, 1608, 1672, 1800, 1928, 2088, 2216, 2344, 2472, 2536, 2664,
                               2792, 2984, 3112, 3240, 3368, 3368, 3496, 3624, 3752, 3880, 4008,
                               4136, 4264, 4392, 4584, 4584, 4776, 4968, 4968, 5160, 5352, 5352,
                               5544, 5736, 5736, 5992, 5992, 6200, 6200, 6456, 6456, 6712, 6712,
                               6712, 6968, 6968, 7224, 7224, 7480, 7480, 7736, 7736, 7992, 7992,
                               8248, 8248, 8504, 8504, 8760, 8760, 8760, 9144, 9144, 9144, 9528,
                               9528, 9528, 9912, 9912, 9912,10296,10296,10296,10680,10680,10680,
                              11064,11064,11064,11448,11448,11448,11448,11832,11832,11832,12216,
                              12216,12216,12576,12576,12576,12960,12960,12960,12960,13536,13536},
                             {  120,  256,  392,  536,  680,  808,  968, 1096, 1256, 1384, 1544,
                               1672, 1800, 1928, 2088, 2216, 2344, 2536, 2664, 2792, 2984, 3112,
                               3240, 3368, 3496, 3624, 3752, 3880, 4008, 4264, 4392, 4584, 4584,
                               4776, 4968, 4968, 5160, 5352, 5544, 5544, 5736, 5992, 5992, 6200,
                               6200, 6456, 6456, 6712, 6968, 6968, 7224, 7224, 7480, 7480, 7736,
                               7736, 7992, 7992, 8248, 8504, 8504, 8760, 8760, 9144, 9144, 9144,
                               9528, 9528, 9528, 9912, 9912, 9912,10296,10296,10680,10680,10680,
                              11064,11064,11064,11448,11448,11448,11832,11832,12216,12216,12216,
                              12576,12576,12576,12960,12960,12960,13536,13536,13536,13536,14112,
                              14112,14112,14112,14688,14688,14688,14688,15264,15264,15264,15264},
                             {  136,  296,  456,  616,  776,  936, 1096, 1256, 1416, 1544, 1736,
                               1864, 2024, 2216, 2344, 2536, 2664, 2856, 2984, 3112, 3368, 3496,
                               3624, 3752, 4008, 4136, 4264, 4392, 4584, 4776, 4968, 5160, 5160,
                               5352, 5544, 5736, 5736, 5992, 6200, 6200, 6456, 6712, 6712, 6968,
                               6968, 7224, 7480, 7480, 7736, 7992, 7992, 8248, 8248, 8504, 8760,
                               8760, 9144, 9144, 9144, 9528, 9528, 9912, 9912,10296,10296,10296,
                              10680,10680,11064,11064,11064,11448,11448,11832,11832,11832,12216,
                              12216,12576,12576,12960,12960,12960,13536,13536,13536,13536,14112,
                              14112,14112,14112,14688,14688,14688,15264,15264,15264,15264,15840,
                              15840,15840,16416,16416,16416,16416,16992,16992,16992,16992,17568},
                             {  144,  328,  504,  680,  872, 1032, 1224, 1384, 1544, 1736, 1928,
                               2088, 2280, 2472, 2664, 2792, 2984, 3112, 3368, 3496, 3752, 3880,
                               4008, 4264, 4392, 4584, 4776, 4968, 5160, 5352, 5544, 5736, 5736,
                               5992, 6200, 6200, 6456, 6712, 6712, 6968, 7224, 7480, 7480, 7736,
                               7992, 7992, 8248, 8504, 8504, 8760, 9144, 9144, 9144, 9528, 9528,
                               9912, 9912,10296,10296,10680,10680,11064,11064,11448,11448,11448,
                              11832,11832,12216,12216,12576,12576,12960,12960,12960,13536,13536,
                              13536,14112,14112,14112,14688,14688,14688,14688,15264,15264,15264,
                              15840,15840,15840,16416,16416,16416,16992,16992,16992,16992,17568,
                              17568,17568,18336,18336,18336,18336,18336,19080,19080,19080,19080},
                             {  176,  376,  584,  776, 1000, 1192, 1384, 1608, 1800, 2024, 2216,
                               2408, 2600, 2792, 2984, 3240, 3496, 3624, 3880, 4008, 4264, 4392,
                               4584, 4776, 4968, 5352, 5544, 5736, 5992, 5992, 6200, 6456, 6712,
                               6968, 6968, 7224, 7480, 7736, 7736, 7992, 8248, 8504, 8760, 8760,
                               9144, 9144, 9528, 9528, 9912, 9912,10296,10680,10680,11064,11064,
                              11448,11448,11832,11832,12216,12216,12576,12576,12960,12960,13536,
                              13536,13536,14112,14112,14112,14688,14688,14688,15264,15264,15840,
                              15840,15840,16416,16416,16416,16992,16992,16992,17568,17568,17568,
                              18336,18336,18336,18336,19080,19080,19080,19080,19848,19848,19848,
                              19848,20616,20616,20616,21384,21384,21384,21384,22152,22152,22152},
                             {  208,  440,  680,  904, 1128, 1352, 1608, 1800, 2024, 2280, 2472,
                               2728, 2984, 3240, 3368, 3624, 3880, 4136, 4392, 4584, 4776, 4968,
                               5352, 5544, 5736, 5992, 6200, 6456, 6712, 6712, 6968, 7224, 7480,
                               7736, 7992, 8248, 8504, 8760, 8760, 9144, 9528, 9528, 9912, 9912,
                              10296,10680,10680,11064,11064,11448,11832,11832,12216,12216,12576,
                              12576,12960,12960,13536,13536,14112,14112,14112,14688,14688,15264,
                              15264,15264,15840,15840,16416,16416,16416,16992,16992,17568,17568,
                              17568,18336,18336,18336,19080,19080,19080,19080,19848,19848,19848,
                              20616,20616,20616,21384,21384,21384,21384,22152,22152,22152,22920,
                              22920,22920,23688,23688,23688,23688,24496,24496,24496,24496,25456},
                             {  224,  488,  744, 1000, 1256, 1544, 1800, 2024, 2280, 2536, 2856,
                               3112, 3368, 3624, 3880, 4136, 4392, 4584, 4968, 5160, 5352, 5736,
                               5992, 6200, 6456, 6712, 6968, 7224, 7480, 7736, 7992, 8248, 8504,
                               8760, 9144, 9144, 9528, 9912, 9912,10296,10680,10680,11064,11448,
                              11448,11832,12216,12216,12576,12960,12960,13536,13536,14112,14112,
                              14688,14688,14688,15264,15264,15840,15840,16416,16416,16992,16992,
                              16992,17568,17568,18336,18336,18336,19080,19080,19080,19848,19848,
                              19848,20616,20616,20616,21384,21384,21384,22152,22152,22152,22920,
                              22920,22920,23688,23688,23688,24496,24496,24496,25456,25456,25456,
                              25456,26416,26416,26416,26416,27376,27376,27376,27376,28336,28336},
                             {  256,  552,  840, 1128, 1416, 1736, 1992, 2280, 2600, 2856, 3112,
                               3496, 3752, 4008, 4264, 4584, 4968, 5160, 5544, 5736, 5992, 6200,
                               6456, 6968, 7224, 7480, 7736, 7992, 8248, 8504, 8760, 9144, 9528,
                               9912, 9912,10296,10680,11064,11064,11448,11832,12216,12216,12576,
                              12960,12960,13536,13536,14112,14112,14688,14688,15264,15264,15840,
                              15840,16416,16416,16992,16992,17568,17568,18336,18336,18336,19080,
                              19080,19848,19848,19848,20616,20616,20616,21384,21384,22152,22152,
                              22152,22920,22920,22920,23688,23688,24496,24496,24496,25456,25456,
                              25456,25456,26416,26416,26416,27376,27376,27376,28336,28336,28336,
                              28336,29296,29296,29296,29296,30576,30576,30576,30576,31704,31704},
                             {  280,  600,  904, 1224, 1544, 1800, 2152, 2472, 2728, 3112, 3368,
                               3624, 4008, 4264, 4584, 4968, 5160, 5544, 5736, 6200, 6456, 6712,
                               6968, 7224, 7736, 7992, 8248, 8504, 8760, 9144, 9528, 9912,10296,
                              10296,10680,11064,11448,11832,11832,12216,12576,12960,12960,13536,
                              13536,14112,14688,14688,15264,15264,15840,15840,16416,16416,16992,
                              16992,17568,17568,18336,18336,18336,19080,19080,19848,19848,20616,
                              20616,20616,21384,21384,22152,22152,22152,22920,22920,23688,23688,
                              23688,24496,24496,24496,25456,25456,25456,26416,26416,26416,27376,
                              27376,27376,28336,28336,28336,29296,29296,29296,29296,30576,30576,
                              30576,30576,31704,31704,31704,31704,32856,32856,32856,34008,34008},
                             {  328,  632,  968, 1288, 1608, 1928, 2280, 2600, 2984, 3240, 3624,
                               3880, 4264, 4584, 4968, 5160, 5544, 5992, 6200, 6456, 6712, 7224,
                               7480, 7736, 7992, 8504, 8760, 9144, 9528, 9912, 9912,10296,10680,
                              11064,11448,11832,12216,12216,12576,12960,13536,13536,14112,14112,
                              14688,14688,15264,15840,15840,16416,16416,16992,16992,17568,17568,
                              18336,18336,19080,19080,19848,19848,19848,20616,20616,21384,21384,
                              22152,22152,22152,22920,22920,23688,23688,24496,24496,24496,25456,
                              25456,25456,26416,26416,26416,27376,27376,27376,28336,28336,28336,
                              29296,29296,29296,30576,30576,30576,30576,31704,31704,31704,31704,
                              32856,32856,32856,34008,34008,34008,34008,35160,35160,35160,35160},
                             {  336,  696, 1064, 1416, 1800, 2152, 2536, 2856, 3240, 3624, 4008,
                               4392, 4776, 5160, 5352, 5736, 6200, 6456, 6712, 7224, 7480, 7992,
                               8248, 8760, 9144, 9528, 9912,10296,10296,10680,11064,11448,11832,
                              12216,12576,12960,13536,13536,14112,14688,14688,15264,15264,15840,
                              16416,16416,16992,17568,17568,18336,18336,19080,19080,19848,19848,
                              20616,20616,20616,21384,21384,22152,22152,22920,22920,23688,23688,
                              24496,24496,24496,25456,25456,26416,26416,26416,27376,27376,27376,
                              28336,28336,29296,29296,29296,30576,30576,30576,30576,31704,31704,
                              31704,32856,32856,32856,34008,34008,34008,35160,35160,35160,35160,
                              36696,36696,36696,36696,37888,37888,37888,39232,39232,39232,39232},
                             {  376,  776, 1160, 1544, 1992, 2344, 2792, 3112, 3624, 4008, 4392,
                               4776, 5160, 5544, 5992, 6200, 6712, 7224, 7480, 7992, 8248, 8760,
                               9144, 9528, 9912,10296,10680,11064,11448,11832,12216,12576,12960,
                              13536,14112,14112,14688,15264,15264,15840,16416,16416,16992,17568,
                              17568,18336,18336,19080,19080,19848,19848,20616,21384,21384,22152,
                              22152,22920,22920,23688,23688,24496,24496,24496,25456,25456,26416,
                              26416,27376,27376,27376,28336,28336,29296,29296,29296,30576,30576,
                              30576,31704,31704,31704,32856,32856,32856,34008,34008,34008,35160,
                              35160,35160,36696,36696,36696,37888,37888,37888,37888,39232,39232,
                              39232,40576,40576,40576,40576,42368,42368,42368,42368,43816,43816},
                             {  408,  840, 1288, 1736, 2152, 2600, 2984, 3496, 3880, 4264, 4776,
                               5160, 5544, 5992, 6456, 6968, 7224, 7736, 8248, 8504, 9144, 9528,
                               9912,10296,10680,11064,11448,12216,12576,12960,13536,13536,14112,
                              14688,15264,15264,15840,16416,16992,16992,17568,18336,18336,19080,
                              19080,19848,20616,20616,21384,21384,22152,22152,22920,22920,23688,
                              24496,24496,25456,25456,25456,26416,26416,27376,27376,28336,28336,
                              29296,29296,29296,30576,30576,30576,31704,31704,32856,32856,32856,
                              34008,34008,34008,35160,35160,35160,36696,36696,36696,37888,37888,
                              37888,39232,39232,39232,40576,40576,40576,40576,42368,42368,42368,
                              43816,43816,43816,43816,45352,45352,45352,46888,46888,46888,46888},
                             {  440,  904, 1384, 1864, 2344, 2792, 3240, 3752, 4136, 4584, 5160,
                               5544, 5992, 6456, 6968, 7480, 7992, 8248, 8760, 9144, 9912,10296,
                              10680,11064,11448,12216,12576,12960,13536,14112,14688,14688,15264,
                              15840,16416,16992,16992,17568,18336,18336,19080,19848,19848,20616,
                              20616,21384,22152,22152,22920,22920,23688,24496,24496,25456,25456,
                              26416,26416,27376,27376,28336,28336,29296,29296,29296,30576,30576,
                              31704,31704,31704,32856,32856,34008,34008,34008,35160,35160,35160,
                              36696,36696,36696,37888,37888,39232,39232,39232,40576,40576,40576,
                              42368,42368,42368,42368,43816,43816,43816,45352,45352,45352,46888,
                              46888,46888,46888,48936,48936,48936,48936,48936,51024,51024,51024},
                             {  488, 1000, 1480, 1992, 2472, 2984, 3496, 4008, 4584, 4968, 5544,
                               5992, 6456, 6968, 7480, 7992, 8504, 9144, 9528, 9912,10680,11064,
                              11448,12216,12576,12960,13536,14112,14688,15264,15840,15840,16416,
                              16992,17568,18336,18336,19080,19848,19848,20616,21384,21384,22152,
                              22920,22920,23688,24496,24496,25456,25456,26416,26416,27376,27376,
                              28336,28336,29296,29296,30576,30576,31704,31704,31704,32856,32856,
                              34008,34008,35160,35160,35160,36696,36696,36696,37888,37888,39232,
                              39232,39232,40576,40576,40576,42368,42368,42368,43816,43816,43816,
                              45352,45352,45352,46888,46888,46888,46888,48936,48936,48936,48936,
                              51024,51024,51024,51024,52752,52752,52752,52752,55056,55056,55056},
                             {  520, 1064, 1608, 2152, 2664, 3240, 3752, 4264, 4776, 5352, 5992,
                               6456, 6968, 7480, 7992, 8504, 9144, 9528,10296,10680,11448,11832,
                              12576,12960,13536,14112,14688,15264,15840,16416,16992,16992,17568,
                              18336,19080,19080,19848,20616,21384,21384,22152,22920,22920,23688,
                              24496,24496,25456,25456,26416,27376,27376,28336,28336,29296,29296,
                              30576,30576,31704,31704,32856,32856,34008,34008,34008,35160,35160,
                              36696,36696,36696,37888,37888,39232,39232,40576,40576,40576,42368,
                              42368,42368,43816,43816,43816,45352,45352,45352,46888,46888,46888,
                              48936,48936,48936,48936,51024,51024,51024,51024,52752,52752,52752,
                              55056,55056,55056,55056,57336,57336,57336,57336,59256,59256,59256},
                             {  552, 1128, 1736, 2280, 2856, 3496, 4008, 4584, 5160, 5736, 6200,
                               6968, 7480, 7992, 8504, 9144, 9912,10296,11064,11448,12216,12576,
                              12960,13536,14112,14688,15264,15840,16416,16992,17568,18336,19080,
                              19848,19848,20616,21384,22152,22152,22920,23688,24496,24496,25456,
                              25456,26416,27376,27376,28336,28336,29296,29296,30576,30576,31704,
                              31704,32856,32856,34008,34008,35160,35160,36696,36696,37888,37888,
                              37888,39232,39232,40576,40576,40576,42368,42368,43816,43816,43816,
                              45352,45352,45352,46888,46888,46888,48936,48936,48936,51024,51024,
                              51024,51024,52752,52752,52752,55056,55056,55056,55056,57336,57336,
                              57336,57336,59256,59256,59256,59256,61664,61664,61664,61664,63776},
                             {  584, 1192, 1800, 2408, 2984, 3624, 4264, 4968, 5544, 5992, 6712,
                               7224, 7992, 8504, 9144, 9912,10296,11064,11448,12216,12960,13536,
                              14112,14688,15264,15840,16416,16992,17568,18336,19080,19848,19848,
                              20616,21384,22152,22920,22920,23688,24496,25456,25456,26416,26416,
                              27376,28336,28336,29296,29296,30576,31704,31704,32856,32856,34008,
                              34008,35160,35160,36696,36696,36696,37888,37888,39232,39232,40576,
                              40576,42368,42368,42368,43816,43816,45352,45352,45352,46888,46888,
                              46888,48936,48936,48936,51024,51024,51024,52752,52752,52752,52752,
                              55056,55056,55056,57336,57336,57336,57336,59256,59256,59256,61664,
                              61664,61664,61664,63776,63776,63776,63776,66592,66592,66592,66592},
                             {  616, 1256, 1864, 2536, 3112, 3752, 4392, 5160, 5736, 6200, 6968,
                               7480, 8248, 8760, 9528,10296,10680,11448,12216,12576,13536,14112,
                              14688,15264,15840,16416,16992,17568,18336,19080,19848,20616,20616,
                              21384,22152,22920,23688,24496,24496,25456,26416,26416,27376,28336,
                              28336,29296,29296,30576,31704,31704,32856,32856,34008,34008,35160,
                              35160,36696,36696,37888,37888,39232,39232,40576,40576,40576,42368,
                              42368,43816,43816,43816,45352,45352,46888,46888,46888,48936,48936,
                              48936,51024,51024,51024,52752,52752,52752,55056,55056,55056,55056,
                              57336,57336,57336,59256,59256,59256,61664,61664,61664,61664,63776,
                              63776,63776,63776,66592,66592,66592,66592,68808,68808,68808,71112},
                             {  712, 1480, 2216, 2984, 3752, 4392, 5160, 5992, 6712, 7480, 8248,
                               8760, 9528,10296,11064,11832,12576,13536,14112,14688,15264,16416,
                              16992,17568,18336,19080,19848,20616,21384,22152,22920,23688,24496,
                              25456,25456,26416,27376,28336,29296,29296,30576,30576,31704,32856,
                              32856,34008,35160,35160,36696,36696,37888,37888,39232,40576,40576,
                              40576,42368,42368,43816,43816,45352,45352,46888,46888,48936,48936,
                              48936,51024,51024,52752,52752,52752,55056,55056,55056,55056,57336,
                              57336,57336,59256,59256,59256,61664,61664,61664,63776,63776,63776,
                              66592,66592,66592,68808,68808,68808,71112,71112,71112,73712,73712,
                              75376,75376,75376,75376,75376,75376,75376,75376,75376,75376,75376}};

/*******************************************************************************
                              LOCAL FUNCTION PROTOTYPES
*******************************************************************************/

/*********************************************************************
    Name: layer_mapper

    Description: Maps complex-valued modulation symbols onto one or
                 several layers

    Document Reference: 3GPP TS 36.211 v10.1.0 section 6.3.3

    NOTES: Currently only supports single antenna or TX diversity
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void layer_mapper(float                          *d_re,
                  float                          *d_im,
                  uint32                          M_symb,
                  uint32                          N_ant,
                  uint32                          N_codewords,
                  LIBLTE_PHY_PRE_CODER_TYPE_ENUM  type,
                  float                          *x_re,
                  float                          *x_im,
                  uint32                         *M_layer_symb);

/*********************************************************************
    Name: layer_demapper

    Description: De-maps one or several layers into complex-valued
                 modulation symbols

    Document Reference: 3GPP TS 36.211 v10.1.0 section 6.3.3

    NOTES: Currently only supports single antenna or TX diversity
*********************************************************************/
// Defines
#define RX_NULL_SYMB 10000
#define TX_NULL_SYMB 100
// Enums
// Structs
// Functions
void layer_demapper(float                          *x_re,
                    float                          *x_im,
                    uint32                          M_layer_symb,
                    uint32                          N_ant,
                    uint32                          N_codewords,
                    LIBLTE_PHY_PRE_CODER_TYPE_ENUM  type,
                    float                          *d_re,
                    float                          *d_im,
                    uint32                         *M_symb);

/*********************************************************************
    Name: pre_coder

    Description: Generates a block of vectors to be mapped onto
                 resources on each antenna port

    Document Reference: 3GPP TS 36.211 v10.1.0 section 6.3.4

    NOTES: Currently only supports signle antenna or TX diversity
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void pre_coder(float                          *x_re,
               float                          *x_im,
               uint32                          M_layer_symb,
               uint32                          N_ant,
               LIBLTE_PHY_PRE_CODER_TYPE_ENUM  type,
               float                          *y_re,
               float                          *y_im,
               uint32                         *M_ap_symb);

/*********************************************************************
    Name: pre_decoder_and_matched_filter

    Description: Matched filters and unmaps a block of vectors from
                 resources on each antenna port

    Document Reference: 3GPP TS 36.211 v10.1.0 section 6.3.4

    NOTES: Currently only supports signle antenna or TX diversity
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void pre_decoder_and_matched_filter(float                          *y_re,
                                    float                          *y_im,
                                    float                          *h_re,
                                    float                          *h_im,
                                    uint32                          h_len,
                                    uint32                          M_ap_symb,
                                    uint32                          N_ant,
                                    LIBLTE_PHY_PRE_CODER_TYPE_ENUM  type,
                                    float                          *x_re,
                                    float                          *x_im,
                                    uint32                         *M_layer_symb);

/*********************************************************************
    Name: generate_crs

    Description: Generates LTE cell specific reference signals

    Document Reference: 3GPP TS 36.211 v10.1.0 section 6.10.1.1
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void generate_crs(uint32  N_s,
                  uint32  L,
                  uint32  N_id_cell,
                  float  *crs_re,
                  float  *crs_im);

/*********************************************************************
    Name: generate_pss

    Description: Generates an LTE primary synchronization signal

    Document Reference: 3GPP TS 36.211 v10.1.0 section 6.11.1.1
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void generate_pss(uint32  N_id_2,
                  float  *pss_re,
                  float  *pss_im);

/*********************************************************************
    Name: generate_sss

    Description: Generates LTE secondary synchronization signals

    Document Reference: 3GPP TS 36.211 v10.1.0 section 6.11.2.1
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void generate_sss(LIBLTE_PHY_STRUCT *phy_struct,
                  uint32             N_id_1,
                  uint32             N_id_2,
                  float             *sss_re_0,
                  float             *sss_im_0,
                  float             *sss_re_5,
                  float             *sss_im_5);

/*********************************************************************
    Name: samples_to_symbols

    Description: Converts I/Q samples to subcarrier symbols

    Document Reference: 3GPP TS 36.211 v10.1.0 section 6.12
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void samples_to_symbols(LIBLTE_PHY_STRUCT *phy_struct,
                        float             *samps_re,
                        float             *samps_im,
                        uint32             slot_start_idx,
                        uint32             symbol_offset,
                        uint32             FFT_pad_size,
                        uint8              scale,
                        float             *symb_re,
                        float             *symb_im);

/*********************************************************************
    Name: modulation_mapper

    Description: Maps binary digits to complex-valued modulation
                 symbols

    Document Reference: 3GPP TS 36.211 v10.1.0 section 7.1

    NOTES: Currently only supports BPSK and QPSK
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void modulation_mapper(uint8                           *bits,
                       uint32                           N_bits,
                       LIBLTE_PHY_MODULATION_TYPE_ENUM  type,
                       float                           *d_re,
                       float                           *d_im,
                       uint32                          *M_symb);

/*********************************************************************
    Name: modulation_demapper

    Description: Maps complex-valued modulation symbols to binary
                 digits

    Document Reference: 3GPP TS 36.211 v10.1.0 section 7.1

    NOTES: Currently only supports BPSK and QPSK
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void modulation_demapper(float                           *d_re,
                         float                           *d_im,
                         uint32                           M_symb,
                         LIBLTE_PHY_MODULATION_TYPE_ENUM  type,
                         int8                            *bits,
                         uint32                          *N_bits);

/*********************************************************************
    Name: generate_prs_c

    Description: Generates the psuedo random sequence c

    Document Reference: 3GPP TS 36.211 v10.1.0 section 7.2
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void generate_prs_c(uint32  c_init,
                    uint32  len,
                    uint32 *c);

/*********************************************************************
    Name: calc_crc

    Description: Calculates one of the LTE CRCs

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.1
*********************************************************************/
// Defines
#define CRC24A 0x01864CFB
#define CRC24B 0x01800063
#define CRC16  0x00011021
#define CRC8   0x0000019B
// Enums
// Structs
// Functions
void calc_crc(uint8  *a_bits,
              uint32  N_a_bits,
              uint32  crc,
              uint8  *p_bits,
              uint32  N_p_bits);

/*********************************************************************
    Name: code_block_segmentation

    Description: Performs code block segmentation for turbo coded
                 channels

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.2
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void code_block_segmentation(uint8  *b_bits,
                             uint32  N_b_bits,
                             uint32 *N_codeblocks,
                             uint32 *N_filler_bits,
                             uint8  *c_bits,
                             uint32  N_c_bits_max,
                             uint32 *N_c_bits);

/*********************************************************************
    Name: code_block_desegmentation

    Description: Performs code block desegmentation for turbo coded
                 channels

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.2
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void code_block_desegmentation(uint8  *c_bits,
                               uint32 *N_c_bits,
                               uint32  N_c_bits_max,
                               uint32  tbs,
                               uint8  *b_bits,
                               uint32  N_b_bits);

/*********************************************************************
    Name: conv_encode

    Description: Convolutionally encodes a bit array using the
                 provided parameters

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.3.1
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void conv_encode(LIBLTE_PHY_STRUCT *phy_struct,
                 uint8             *c_bits,
                 uint32             N_c_bits,
                 uint32             constraint_len,
                 uint32             rate,
                 uint32            *g,
                 bool               tail_bit,
                 uint8             *d_bits,
                 uint32            *N_d_bits);

/*********************************************************************
    Name: viterbi_decode

    Description: Viterbi decodes a convolutionally coded input bit
                 array using the provided parameters

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.3.1
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void viterbi_decode(LIBLTE_PHY_STRUCT *phy_struct,
                    float             *d_bits,
                    uint32             N_d_bits,
                    uint32             constraint_len,
                    uint32             rate,
                    uint32            *g,
                    uint8             *c_bits,
                    uint32            *N_c_bits);

/*********************************************************************
    Name: turbo_encode

    Description: Turbo encodes a bit array using the LTE Parallel
                 Concatenated Convolutional Code

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.3.2

    Notes: Currently not handling filler bits
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void turbo_encode(LIBLTE_PHY_STRUCT *phy_struct,
                  uint8             *c_bits,
                  uint32             N_c_bits,
                  uint32             N_fill_bits,
                  uint8             *d_bits,
                  uint32            *N_d_bits);

/*********************************************************************
    Name: turbo_decode

    Description: Turbo decodes data according to the LTE Parallel
                 Concatenated Convolutional Code.  The design of this
                 decoder is based on the conversion of the constituent
                 coder from:
                                   -------->+---------------->+---- out
                                   |        ^                 ^
                           in_act  |   |-|  |   |-|      |-|  |
                 in --->+------------->|D|----->|D|----->|D|---
                        ^              |-|      |-|  |   |-|  |
                        |                            v        |
                        -----------------------------+<--------
                 to:
                           ------->+---------------->+------------- out
                           |       ^                 ^
                           |  |-|  |   |-|      |-|  |       
                 in_act ------|D|----->|D|----->|D|---         
                           |  |-|      |-|  |   |-|  |          
                           |                v        v         
                           ---------------->+------->+------------- in
                 in_act can be determined using viterbi decoding and
                 a second copy of in can be calculated using in_act

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.3.2

    Notes: Currently not handling filler bits
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void turbo_decode(LIBLTE_PHY_STRUCT *phy_struct,
                  float             *d_bits,
                  uint32             N_d_bits,
                  uint32             N_fill_bits,
                  uint8             *c_bits,
                  uint32            *N_c_bits);

/*********************************************************************
    Name: turbo_constituent_encoder

    Description: Constituent encoder for the LTE Parallel Concatenated
                 Convolutional Code

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.3.2
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void turbo_constituent_encoder(uint8  *in_bits,
                               uint32  N_in_bits,
                               uint8  *out_bits,
                               uint8  *fb_bits);

/*********************************************************************
    Name: turbo_internal_interleaver

    Description: Internal interleaver for the LTE Parallel
                 Concatenated Convolutional Code

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.3.2
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void turbo_internal_interleaver(uint8  *in_bits,
                                uint32  N_in_bits,
                                uint8  *out_bits);
void turbo_internal_interleaver(float  *in_bits,
                                uint32  N_in_bits,
                                float  *out_bits);

/*********************************************************************
    Name: turbo_internal_deinterleaver

    Description: Internal Deinterleaver for the LTE Parallel
                 Concatenated Convolutional Code

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.3.2
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void turbo_internal_deinterleaver(float  *in_bits,
                                  uint32  N_in_bits,
                                  float  *out_bits);

/*********************************************************************
    Name: rate_match_turbo

    Description: Rate matches turbo encoded data

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.4.1
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void rate_match_turbo(LIBLTE_PHY_STRUCT         *phy_struct,
                      uint8                     *d_bits,
                      uint32                     N_d_bits,
                      uint32                     N_codeblocks,
                      uint32                     tx_mode,
                      uint32                     N_soft,
                      uint32                     M_dl_harq,
                      LIBLTE_PHY_CHAN_TYPE_ENUM  chan_type,
                      uint32                     rv_idx,
                      uint32                     N_e_bits,
                      uint8                     *e_bits);

/*********************************************************************
    Name: rate_unmatch_turbo

    Description: Rate unmatches turbo encoded data

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.4.1
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void rate_unmatch_turbo(LIBLTE_PHY_STRUCT         *phy_struct,
                        float                     *e_bits,
                        uint32                     N_e_bits,
                        uint8                     *dummy_bits,
                        uint32                     N_dummy_bits,
                        uint32                     N_codeblocks,
                        uint32                     tx_mode,
                        uint32                     N_soft,
                        uint32                     M_dl_harq,
                        LIBLTE_PHY_CHAN_TYPE_ENUM  chan_type,
                        uint32                     rv_idx,
                        float                     *d_bits,
                        uint32                    *N_d_bits);

/*********************************************************************
    Name: rate_match_conv

    Description: Rate matches convolutionally encoded data

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.4.2
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void rate_match_conv(LIBLTE_PHY_STRUCT *phy_struct,
                     uint8             *d_bits,
                     uint32             N_d_bits,
                     uint32             N_e_bits,
                     uint8             *e_bits);

/*********************************************************************
    Name: rate_unmatch_conv

    Description: Rate unmatches convolutionally encoded data

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.4.2
*********************************************************************/
// Defines
#define RX_NULL_BIT 10000
#define TX_NULL_BIT 100
// Enums
// Structs
// Functions
void rate_unmatch_conv(LIBLTE_PHY_STRUCT *phy_struct,
                       float             *e_bits,
                       uint32             N_e_bits,
                       uint32             N_c_bits,
                       float             *d_bits,
                       uint32            *N_d_bits);

/*********************************************************************
    Name: code_block_concatenation

    Description: Performs code block concatenation for turbo coded
                 channels

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.5
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void code_block_concatenation(uint8  *e_bits,
                              uint32  N_e_bits,
                              uint32  N_e_bits_max,
                              uint32  N_codeblocks,
                              uint8  *f_bits,
                              uint32 *N_f_bits);

/*********************************************************************
    Name: code_block_deconcatenation

    Description: Performs code block deconcatenation for turbo coded
                 channels

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.5
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void code_block_deconcatenation(float  *f_bits,
                                uint32  N_f_bits,
                                uint32  tbs,
                                float  *e_bits,
                                uint32 *N_e_bits,
                                uint32  N_e_bits_max,
                                uint32 *N_codeblocks);

/*********************************************************************
    Name: bch_channel_encode

    Description: Channel encodes the broadcast channel

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.3.1
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void bch_channel_encode(LIBLTE_PHY_STRUCT *phy_struct,
                        uint8             *in_bits,
                        uint32             N_in_bits,
                        uint8              N_ant,
                        uint8             *out_bits,
                        uint32            *N_out_bits);

/*********************************************************************
    Name: bch_channel_decode

    Description: Channel decodes the broadcast channel

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.3.1
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
LIBLTE_ERROR_ENUM bch_channel_decode(LIBLTE_PHY_STRUCT *phy_struct,
                                     float             *in_bits,
                                     uint32             N_in_bits,
                                     uint8             *N_ant,
                                     uint8             *out_bits,
                                     uint32            *N_out_bits);

/*********************************************************************
    Name: dlsch_channel_encode

    Description: Channel encodes the Downlink Shared Channel

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.3.2
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void dlsch_channel_encode(LIBLTE_PHY_STRUCT *phy_struct,
                          uint8             *in_bits,
                          uint32             N_in_bits,
                          uint32             tx_mode,
                          uint32             rv_idx,
                          uint32             G,
                          uint32             N_l,
                          uint32             Q_m,
                          uint32             M_dl_harq,
                          uint32             N_soft,
                          uint8             *out_bits,
                          uint32            *N_out_bits);

/*********************************************************************
    Name: dlsch_channel_decode

    Description: Channel decodes the Downlink Shared Channel

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.3.2
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
LIBLTE_ERROR_ENUM dlsch_channel_decode(LIBLTE_PHY_STRUCT *phy_struct,
                                       float             *in_bits,
                                       uint32             N_in_bits,
                                       uint32             tbs,
                                       uint32             tx_mode,
                                       uint32             rv_idx,
                                       uint32             M_dl_harq,
                                       uint32             N_soft,
                                       uint8             *out_bits,
                                       uint32            *N_out_bits);

/*********************************************************************
    Name: dci_channel_encode

    Description: Channel encodes the Downlink Control Information
                 channel

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.3.3
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void dci_channel_encode(LIBLTE_PHY_STRUCT *phy_struct,
                        uint8             *in_bits,
                        uint32             N_in_bits,
                        uint16             rnti,
                        uint8              ue_ant,
                        uint8             *out_bits,
                        uint32            *N_out_bits);

/*********************************************************************
    Name: dci_channel_decode

    Description: Channel decodes the Downlink Control Information
                 channel

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.3.3
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
LIBLTE_ERROR_ENUM dci_channel_decode(LIBLTE_PHY_STRUCT *phy_struct,
                                     float             *in_bits,
                                     uint32             N_in_bits,
                                     uint16             rnti,
                                     uint8              ue_ant,
                                     uint8             *out_bits,
                                     uint32             N_out_bits);

/*********************************************************************
    Name: dci_1a_unpack

    Description: Unpacks all of the fields from the Downlink Control
                 Information format 1A

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.3.3.1.3
                        3GPP TS 36.213 v10.3.0 section 7.1.6.3
                        3GPP TS 36.213 v10.3.0 section 7.1.7

    Notes: Currently only handles SI-RNTI or P-RNTI, and localized
           virtual resource blocks
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void dci_1a_unpack(uint8                           *in_bits,
                   uint32                           N_in_bits,
                   LIBLTE_PHY_DCI_CA_PRESENCE_ENUM  ca_presence,
                   uint16                           rnti,
                   uint32                           N_rb_dl,
                   uint8                            N_ant,
                   LIBLTE_PHY_ALLOCATION_STRUCT    *alloc);

/*********************************************************************
    Name: cfi_channel_encode

    Description: Channel encodes the Control Format Indicator channel

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.3.4
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
void cfi_channel_encode(LIBLTE_PHY_STRUCT *phy_struct,
                        uint32             cfi,
                        uint8             *out_bits,
                        uint32            *N_out_bits);

/*********************************************************************
    Name: cfi_channel_decode

    Description: Channel decodes the Control Format Indicator channel

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.3.4
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
LIBLTE_ERROR_ENUM cfi_channel_decode(LIBLTE_PHY_STRUCT *phy_struct,
                                     float             *in_bits,
                                     uint32             N_in_bits,
                                     uint32            *cfi);

/*********************************************************************
    Name: get_soft_decision

    Description: Determines the magnitude of the soft decision

    Document Reference: N/A
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
float get_soft_decision(float p1_re,
                        float p1_im,
                        float p2_re,
                        float p2_im,
                        float max_dist);

/*********************************************************************
    Name: phy_bits_2_value

    Description: Converts a bit string to a value

    Document Reference: N/A
*********************************************************************/
// Defines
// Enums
// Structs
// Functions
uint32 phy_bits_2_value(uint8  **bits,
                        uint32   N_bits);

/*******************************************************************************
                              LIBRARY FUNCTIONS
*******************************************************************************/

/*********************************************************************
    Name: liblte_phy_init

    Description: Initializes the LTE Physical Layer library.

    Document Reference: N/A
*********************************************************************/
LIBLTE_ERROR_ENUM liblte_phy_init(LIBLTE_PHY_STRUCT **phy_struct)
{
    LIBLTE_ERROR_ENUM err = LIBLTE_ERROR_INVALID_INPUTS;

    if(phy_struct != NULL)
    {
        *phy_struct = (LIBLTE_PHY_STRUCT *)malloc(sizeof(LIBLTE_PHY_STRUCT));

//        /* Samples to symbols */
//        phy_struct->in   = (fftw_complex *)fftw_malloc(sizeof(fftw_complex)*2048*20);
//        phy_struct->out  = (fftw_complex *)fftw_malloc(sizeof(fftw_complex)*2048*20);
//        phy_struct->plan = fftw_plan_dft_1d(2048,
//                                            phy_struct->in,
//                                            phy_struct->out,
//                                            FFTW_FORWARD,
//                                            FFTW_ESTIMATE);

        err = LIBLTE_SUCCESS;
    }

    return(err);
}

/*********************************************************************
    Name: liblte_phy_cleanup

    Description: Cleans up the LTE Physical Layer library.

    Document Reference: N/A
*********************************************************************/
LIBLTE_ERROR_ENUM liblte_phy_cleanup(LIBLTE_PHY_STRUCT *phy_struct)
{
    LIBLTE_ERROR_ENUM err = LIBLTE_ERROR_INVALID_INPUTS;

    if(phy_struct != NULL)
    {
//        /* Samples to symbols */
//        fftw_destroy_plan(phy_struct->plan);
//        fftw_free(phy_struct->in);
//        fftw_free(phy_struct->out);

        free(phy_struct);
        err = LIBLTE_SUCCESS;
    }

    return(err);
}

/*********************************************************************
    Name: liblte_phy_find_coarse_timing_and_freq_offset

    Description: Finds coarse time syncronization and frequency offset
                 by auto-correlating to find the cyclic prefix on
                 reference signal symbols.

    Document Reference: 3GPP TS 36.211 v10.1.0
*********************************************************************/
LIBLTE_ERROR_ENUM liblte_phy_find_coarse_timing_and_freq_offset(LIBLTE_PHY_STRUCT *phy_struct,
                                                                float             *i_samps,
                                                                float             *q_samps,
                                                                uint32            *symb_starts,
                                                                float             *freq_offset)
{
    LIBLTE_ERROR_ENUM err = LIBLTE_ERROR_INVALID_INPUTS;
    float             corr_re;
    float             corr_im;
    float             abs_corr_max;
    int32             abs_corr_idx[2];
    uint32            slot;
    uint32            i;
    uint32            j;
    uint32            k;
    uint32            idx;

    if(phy_struct  != NULL &&
       i_samps     != NULL &&
       q_samps     != NULL &&
       symb_starts != NULL &&
       freq_offset != NULL)
    {
        // Rough correlation
        memset(phy_struct->timing_abs_corr, 0, 15360*sizeof(float));
        for(slot=0; slot<10; slot++)
        {
            for(i=0; i<15360; i+=40)
            {
                corr_re = 0;
                corr_im = 0;
                for(j=0; j<144; j++)
                {
                    idx      = (slot*15360) + i + j;
                    corr_re += i_samps[idx]*i_samps[idx+2048] + q_samps[idx]*q_samps[idx+2048];
                    corr_im += i_samps[idx]*q_samps[idx+2048] - q_samps[idx]*i_samps[idx+2048];
                }
                phy_struct->timing_abs_corr[i] += corr_re*corr_re + corr_im*corr_im;
            }
        }

        // Find first and second max
        for(i=0; i<2; i++)
        {
            abs_corr_idx[i] = 0;
            abs_corr_max    = 0;
            for(j=0; j<7680; j++)
            {
                if(phy_struct->timing_abs_corr[(i*7680)+j] > abs_corr_max)
                {
                    abs_corr_max    = phy_struct->timing_abs_corr[(i*7680)+j];
                    abs_corr_idx[i] = (i*7680)+j;
                }
            }
        }

        // Fine correlation and fractional frequency offset
        memset(phy_struct->timing_abs_corr, 0, 15360*sizeof(float));
        memset(phy_struct->timing_corr_freq_err, 0, 15360*sizeof(float));
        for(slot=0; slot<10; slot++)
        {
            for(i=0; i<2; i++)
            {
                if((abs_corr_idx[i] - 40) < 0)
                {
                    abs_corr_idx[i] = 40;
                }
                if((abs_corr_idx[i] + 40) > 15359)
                {
                    abs_corr_idx[i] = 15359 - 40;
                }
                for(j=abs_corr_idx[i]-40; j<(uint32)(abs_corr_idx[i]+41); j++)
                {
                    corr_re = 0;
                    corr_im = 0;
                    for(k=0; k<144; k++)
                    {
                        idx      = (slot*15360) + j + k;
                        corr_re += i_samps[idx]*i_samps[idx+2048] + q_samps[idx]*q_samps[idx+2048];
                        corr_im += i_samps[idx]*q_samps[idx+2048] - q_samps[idx]*i_samps[idx+2048];
                    }
                    phy_struct->timing_abs_corr[j]      += corr_re*corr_re + corr_im*corr_im;
                    phy_struct->timing_corr_freq_err[j] += atan2f(corr_im, corr_re)/(2048*2*M_PI*(0.0005/15360));
                }
            }
        }

        // Find first and second max
        for(i=0; i<2; i++)
        {
            abs_corr_idx[i] = 0;
            abs_corr_max    = 0;
            for(j=0; j<7680; j++)
            {
                if(phy_struct->timing_abs_corr[(i*7680)+j] > abs_corr_max)
                {
                    abs_corr_max    = phy_struct->timing_abs_corr[(i*7680)+j];
                    abs_corr_idx[i] = (i*7680)+j;
                }
            }
        }

        // Determine frequency offset
        // FIXME: No integer offset is calculated
        *freq_offset = ((phy_struct->timing_corr_freq_err[abs_corr_idx[0]]/10 +
                         phy_struct->timing_corr_freq_err[abs_corr_idx[1]]/10)/2);

        // Determine the symbol start locations from the correlation peaks
        // FIXME: Needs some work
        while(abs_corr_idx[0] > 0)
        {
            abs_corr_idx[0] -= 2192;
        }
        for(i=0; i<7; i++)
        {
            symb_starts[i] = abs_corr_idx[0] + ((i+1)*2192);
        }

        err = LIBLTE_SUCCESS;
    }

    return(err);
}

/*********************************************************************
    Name: liblte_phy_find_pss_and_fine_timing

    Description: Searches for the Primary Synchronization Signal and
                 determines fine timing.

    Document Reference: 3GPP TS 36.211 v10.1.0 section 6.11.1
*********************************************************************/
LIBLTE_ERROR_ENUM liblte_phy_find_pss_and_fine_timing(LIBLTE_PHY_STRUCT *phy_struct,
                                                      float             *i_samps,
                                                      float             *q_samps,
                                                      uint32            *symb_starts,
                                                      uint32            *N_id_2,
                                                      uint32            *pss_symb,
                                                      float             *pss_thresh)
{
    LIBLTE_ERROR_ENUM err = LIBLTE_ERROR_INVALID_INPUTS;
    float             corr_re;
    float             corr_im;
    float             abs_corr;
    float             corr_max;
    float             pss_re[63];
    float             pss_im[63];
    int32             i;
    uint32            j;
    uint32            k;
    uint32            z;
    uint32            N_s;
    uint32            N_symb;
    uint32            pss_timing_idx;
    int8              timing;

    if(phy_struct  != NULL &&
       i_samps     != NULL &&
       q_samps     != NULL &&
       symb_starts != NULL &&
       N_id_2      != NULL &&
       pss_symb    != NULL &&
       pss_thresh  != NULL)
    {
        // Generate PSS
        memset(phy_struct->pss_mod_re, 0, sizeof(float)*3*LIBLTE_PHY_N_RB_DL_20MHZ*LIBLTE_PHY_N_SC_RB_NORMAL_CP);
        memset(phy_struct->pss_mod_im, 0, sizeof(float)*3*LIBLTE_PHY_N_RB_DL_20MHZ*LIBLTE_PHY_N_SC_RB_NORMAL_CP);
        for(i=0; i<3; i++)
        {
            generate_pss(i, pss_re, pss_im);
            for(j=0; j<62; j++)
            {
                k                            = j - 31 + (LIBLTE_PHY_N_RB_DL_20MHZ*LIBLTE_PHY_N_SC_RB_NORMAL_CP)/2;
                phy_struct->pss_mod_re[i][k] = pss_re[j];
                phy_struct->pss_mod_im[i][k] = pss_im[j];
            }
        }

        // Demod symbols and correlate with PSS
        corr_max = 0;
        for(i=0; i<12; i++)
        {
            for(j=0; j<N_SYMB_DL_NORMAL_CP; j++)
            {
                samples_to_symbols(phy_struct,
                                   i_samps,
                                   q_samps,
                                   symb_starts[j]+(15360*i),
                                   0,
                                   LIBLTE_PHY_FFT_PAD_SIZE_20MHZ,
                                   0,
                                   phy_struct->symb_re,
                                   phy_struct->symb_im);

                for(k=0; k<3; k++)
                {
                    corr_re = 0;
                    corr_im = 0;
                    for(z=0; z<LIBLTE_PHY_N_RB_DL_20MHZ*LIBLTE_PHY_N_SC_RB_NORMAL_CP; z++)
                    {
                        corr_re += (phy_struct->symb_re[z]*phy_struct->pss_mod_re[k][z] +
                                    phy_struct->symb_im[z]*phy_struct->pss_mod_im[k][z]);
                        corr_im += (phy_struct->symb_re[z]*phy_struct->pss_mod_im[k][z] -
                                    phy_struct->symb_im[z]*phy_struct->pss_mod_re[k][z]);
                    }
                    abs_corr = sqrt(corr_re*corr_re + corr_im*corr_im);
                    if(abs_corr > corr_max)
                    {
                        corr_max  = abs_corr;
                        *pss_symb = (i*N_SYMB_DL_NORMAL_CP)+j;
                        *N_id_2   = k;
                    }
                }
            }
        }

        // Find optimal timing
        N_s      = (*pss_symb)/7;
        N_symb   = (*pss_symb)%7;
        corr_max = 0;
        timing   = 0;
        for(i=-40; i<40; i++)
        {
            samples_to_symbols(phy_struct,
                               i_samps,
                               q_samps,
                               symb_starts[N_symb]+i+(15360*N_s),
                               0,
                               LIBLTE_PHY_FFT_PAD_SIZE_20MHZ,
                               0,
                               phy_struct->symb_re,
                               phy_struct->symb_im);

            corr_re = 0;
            corr_im = 0;
            for(j=0; j<LIBLTE_PHY_N_RB_DL_20MHZ*LIBLTE_PHY_N_SC_RB_NORMAL_CP; j++)
            {
                corr_re += (phy_struct->symb_re[j]*phy_struct->pss_mod_re[*N_id_2][j] +
                            phy_struct->symb_im[j]*phy_struct->pss_mod_im[*N_id_2][j]);
                corr_im += (phy_struct->symb_re[j]*phy_struct->pss_mod_im[*N_id_2][j] -
                            phy_struct->symb_im[j]*phy_struct->pss_mod_re[*N_id_2][j]);
            }
            abs_corr = sqrt(corr_re*corr_re + corr_im*corr_im);
            if(abs_corr > corr_max)
            {
                corr_max = abs_corr;
                timing   = i;
            }
        }
        *pss_thresh = corr_max;

        // Construct fine symbol start locations
        pss_timing_idx = symb_starts[N_symb]+(15360*N_s)+timing;
        while((pss_timing_idx + 2048 + 144) < 15360)
        {
            pss_timing_idx += 307200;
        }
        symb_starts[0] = pss_timing_idx + (2048+144)*1 - 15360;
        symb_starts[1] = pss_timing_idx + (2048+144)*1 + 2048+160- 15360;
        symb_starts[2] = pss_timing_idx + (2048+144)*2 + 2048+160- 15360;
        symb_starts[3] = pss_timing_idx + (2048+144)*3 + 2048+160- 15360;
        symb_starts[4] = pss_timing_idx + (2048+144)*4 + 2048+160- 15360;
        symb_starts[5] = pss_timing_idx + (2048+144)*5 + 2048+160- 15360;
        symb_starts[6] = pss_timing_idx + (2048+144)*6 + 2048+160- 15360;

        err = LIBLTE_SUCCESS;
    }

    return(err);
}

/*********************************************************************
    Name: liblte_phy_find_sss

    Description: Searches for the Secondary Synchronization Signal.

    Document Reference: 3GPP TS 36.211 v10.1.0 section 6.11.2
*********************************************************************/
LIBLTE_ERROR_ENUM liblte_phy_find_sss(LIBLTE_PHY_STRUCT *phy_struct,
                                      float             *i_samps,
                                      float             *q_samps,
                                      uint32             N_id_2,
                                      uint32            *symb_starts,
                                      float              pss_thresh,
                                      uint32            *N_id_1,
                                      uint32            *frame_start_idx)
{
    LIBLTE_ERROR_ENUM err = LIBLTE_ERROR_INVALID_INPUTS;
    float             sss_thresh;
    float             corr_re;
    float             corr_im;
    float             abs_corr;
    uint32            i;
    uint32            j;
    uint32            k;

    if(phy_struct      != NULL &&
       i_samps         != NULL &&
       q_samps         != NULL &&
       symb_starts     != NULL &&
       N_id_1          != NULL &&
       frame_start_idx != NULL)
    {
        // Generate secondary synchronization signals
        memset(phy_struct->sss_mod_re_0, 0, sizeof(float)*168*LIBLTE_PHY_N_RB_DL_20MHZ*LIBLTE_PHY_N_SC_RB_NORMAL_CP);
        memset(phy_struct->sss_mod_im_0, 0, sizeof(float)*168*LIBLTE_PHY_N_RB_DL_20MHZ*LIBLTE_PHY_N_SC_RB_NORMAL_CP);
        memset(phy_struct->sss_mod_re_5, 0, sizeof(float)*168*LIBLTE_PHY_N_RB_DL_20MHZ*LIBLTE_PHY_N_SC_RB_NORMAL_CP);
        memset(phy_struct->sss_mod_im_5, 0, sizeof(float)*168*LIBLTE_PHY_N_RB_DL_20MHZ*LIBLTE_PHY_N_SC_RB_NORMAL_CP);
        for(i=0; i<168; i++)
        {
            generate_sss(phy_struct,
                         i,
                         N_id_2,
                         phy_struct->sss_re_0,
                         phy_struct->sss_im_0,
                         phy_struct->sss_re_5,
                         phy_struct->sss_im_5);
            for(j=0; j<62; j++)
            {
                k                              = j - 31 + (LIBLTE_PHY_N_RB_DL_20MHZ*LIBLTE_PHY_N_SC_RB_NORMAL_CP)/2;
                phy_struct->sss_mod_re_0[i][k] = phy_struct->sss_re_0[j];
                phy_struct->sss_mod_im_0[i][k] = phy_struct->sss_im_0[j];
                phy_struct->sss_mod_re_5[i][k] = phy_struct->sss_re_5[j];
                phy_struct->sss_mod_im_5[i][k] = phy_struct->sss_im_5[j];
            }
        }
        sss_thresh = pss_thresh * 0.9;

        // Demod symbol and search for secondary synchronization signals
        samples_to_symbols(phy_struct,
                           i_samps,
                           q_samps,
                           symb_starts[5],
                           0,
                           LIBLTE_PHY_FFT_PAD_SIZE_20MHZ,
                           0,
                           phy_struct->symb_re,
                           phy_struct->symb_im);
        for(i=0; i<168; i++)
        {
            corr_re = 0;
            corr_im = 0;
            for(j=0; j<(LIBLTE_PHY_N_RB_DL_20MHZ*LIBLTE_PHY_N_SC_RB_NORMAL_CP); j++)
            {
                corr_re += (phy_struct->symb_re[j]*phy_struct->sss_mod_re_0[i][j] +
                            phy_struct->symb_im[j]*phy_struct->sss_mod_im_0[i][j]);
                corr_im += (phy_struct->symb_re[j]*phy_struct->sss_mod_im_0[i][j] -
                            phy_struct->symb_im[j]*phy_struct->sss_mod_re_0[i][j]);
            }
            abs_corr = sqrt(corr_re*corr_re + corr_im*corr_im);
            if(abs_corr > sss_thresh)
            {
                while(symb_starts[5] < ((2048 + N_CP_L_ELSE)*4 + 2048 + N_CP_L_0))
                {
                    symb_starts[5] += 307200;
                }
                *N_id_1          = i;
                *frame_start_idx = symb_starts[5] - ((2048 + N_CP_L_ELSE)*4 + 2048 + N_CP_L_0);
                break;
            }

            corr_re = 0;
            corr_im = 0;
            for(j=0; j<(LIBLTE_PHY_N_RB_DL_20MHZ*LIBLTE_PHY_N_SC_RB_NORMAL_CP); j++)
            {
                corr_re += (phy_struct->symb_re[j]*phy_struct->sss_mod_re_5[i][j] +
                            phy_struct->symb_im[j]*phy_struct->sss_mod_im_5[i][j]);
                corr_im += (phy_struct->symb_re[j]*phy_struct->sss_mod_im_5[i][j] -
                            phy_struct->symb_im[j]*phy_struct->sss_mod_re_5[i][j]);
            }
            abs_corr = sqrt(corr_re*corr_re + corr_im*corr_im);
            if(abs_corr > sss_thresh)
            {
                while(symb_starts[5] < (((2048 + N_CP_L_ELSE)*4 + 2048 + N_CP_L_0) + 15360*10))
                {
                    symb_starts[5] += 307200;
                }
                *N_id_1          = i;
                *frame_start_idx = symb_starts[5] - ((2048 + N_CP_L_ELSE)*4 + 2048 + N_CP_L_0) - 15360*10;
                break;
            }
        }

        err = LIBLTE_SUCCESS;
    }

    return(err);
}

/*********************************************************************
    Name: liblte_phy_get_subframe_and_ce

    Description: Resolves all symbols and channel estimates for a
                 particular subframe

    Document Reference: 3GPP TS 36.211 v10.1.0
*********************************************************************/
LIBLTE_ERROR_ENUM liblte_phy_get_subframe_and_ce(LIBLTE_PHY_STRUCT          *phy_struct,
                                                 float                      *i_samps,
                                                 float                      *q_samps,
                                                 uint32                      frame_start_idx,
                                                 uint8                       subfr_num,
                                                 uint32                      FFT_pad_size,
                                                 uint32                      N_rb_dl,
                                                 uint32                      N_id_cell,
                                                 uint8                       N_ant,
                                                 LIBLTE_PHY_SUBFRAME_STRUCT *subframe)
{
    LIBLTE_ERROR_ENUM  err = LIBLTE_ERROR_INVALID_INPUTS;
    float             *sym_re;
    float             *sym_im;
    float             *rs_re;
    float             *rs_im;
    float              tmp_re;
    float              tmp_im;
    float              frac_mag = 0;
    float              frac_ang = 0;
    float              ce_mag;
    float              ce_ang;
    uint32             v_shift         = N_id_cell % 6;
    uint32             subfr_start_idx = frame_start_idx + subfr_num*30720;
    uint32             N_sym;
    uint32             m_prime;
    uint32             i;
    uint32             j;
    uint32             k = 0;
    uint32             p;
    uint32             v[5];
    uint32             sym[5];
    uint32             z;

    if(phy_struct != NULL &&
       i_samps    != NULL &&
       q_samps    != NULL &&
       (N_ant     == 1    ||
        N_ant     == 2    ||
        N_ant     == 4)   &&
       subframe   != NULL)
    {
        subframe->num = subfr_num;
        for(i=0; i<16; i++)
        {
            // Demodulate symbols
            samples_to_symbols(phy_struct,
                               i_samps,
                               q_samps,
                               subfr_start_idx + (i/7)*15360,
                               i%7,
                               FFT_pad_size,
                               0,
                               &subframe->symb_re[i][0],
                               &subframe->symb_im[i][0]);
        }

        // Generate cell specific reference signals
        generate_crs((subfr_num*2+0)%20, 0, N_id_cell, phy_struct->ce_crs_re[0],  phy_struct->ce_crs_im[0]);
        generate_crs((subfr_num*2+0)%20, 1, N_id_cell, phy_struct->ce_crs_re[1],  phy_struct->ce_crs_im[1]);
        generate_crs((subfr_num*2+0)%20, 4, N_id_cell, phy_struct->ce_crs_re[4],  phy_struct->ce_crs_im[4]);
        generate_crs((subfr_num*2+1)%20, 0, N_id_cell, phy_struct->ce_crs_re[7],  phy_struct->ce_crs_im[7]);
        generate_crs((subfr_num*2+1)%20, 1, N_id_cell, phy_struct->ce_crs_re[8],  phy_struct->ce_crs_im[8]);
        generate_crs((subfr_num*2+1)%20, 4, N_id_cell, phy_struct->ce_crs_re[11], phy_struct->ce_crs_im[11]);
        generate_crs((subfr_num*2+2)%20, 0, N_id_cell, phy_struct->ce_crs_re[14], phy_struct->ce_crs_im[14]);
        generate_crs((subfr_num*2+2)%20, 1, N_id_cell, phy_struct->ce_crs_re[15], phy_struct->ce_crs_im[15]);

        // Determine channel estimates
        for(p=0; p<N_ant; p++)
        {
            // Define v, crs, sym, and N_sym
            if(p == 0)
            {
                v[0]   = 0;
                v[1]   = 3;
                v[2]   = 0;
                v[3]   = 3;
                v[4]   = 0;
                sym[0] = 0;
                sym[1] = 4;
                sym[2] = 7;
                sym[3] = 11;
                sym[4] = 14;
                N_sym  = 5;
            }else if(p == 1){
                v[0]   = 3;
                v[1]   = 0;
                v[2]   = 3;
                v[3]   = 0;
                v[4]   = 3;
                sym[0] = 0;
                sym[1] = 4;
                sym[2] = 7;
                sym[3] = 11;
                sym[4] = 14;
                N_sym  = 5;
            }else if(p == 2){
                v[0]   = 0;
                v[1]   = 3;
                v[2]   = 0;
                sym[0] = 1;
                sym[1] = 8;
                sym[2] = 15;
                N_sym  = 3;
            }else{ // p == 3
                v[0]   = 3;
                v[1]   = 6;
                v[2]   = 3;
                sym[0] = 1;
                sym[1] = 8;
                sym[2] = 15;
                N_sym  = 3;
            }

            for(i=0; i<N_sym; i++)
            {
                sym_re = &subframe->symb_re[sym[i]][0];
                sym_im = &subframe->symb_im[sym[i]][0];
                rs_re  = &phy_struct->ce_crs_re[sym[i]][0];
                rs_im  = &phy_struct->ce_crs_im[sym[i]][0];

                for(j=0; j<2*N_rb_dl; j++)
                {
                    k                        = 6*j + (v[i] + v_shift)%6;
                    m_prime                  = j + LIBLTE_PHY_N_RB_DL_MAX - N_rb_dl;
                    tmp_re                   = sym_re[k]*rs_re[m_prime] + sym_im[k]*rs_im[m_prime];
                    tmp_im                   = sym_im[k]*rs_re[m_prime] - sym_re[k]*rs_im[m_prime];
                    phy_struct->ce_mag[i][k] = sqrt(tmp_re*tmp_re + tmp_im*tmp_im);
                    phy_struct->ce_ang[i][k] = atan2f(tmp_im, tmp_re);

                    // Unwrap phase
                    if(j > 0)
                    {
                        while((phy_struct->ce_ang[i][k] - phy_struct->ce_ang[i][k-6]) > M_PI)
                        {
                            phy_struct->ce_ang[i][k] -= 2*M_PI;
                        }
                        while((phy_struct->ce_ang[i][k] - phy_struct->ce_ang[i][k-6]) < -M_PI)
                        {
                            phy_struct->ce_ang[i][k] += 2*M_PI;
                        }

                        // Linearly interpolate between CRSs
                        frac_mag = (phy_struct->ce_mag[i][k] - phy_struct->ce_mag[i][k-6])/6;
                        frac_ang = (phy_struct->ce_ang[i][k] - phy_struct->ce_ang[i][k-6])/6;
                        for(z=1; z<6; z++)
                        {
                            phy_struct->ce_mag[i][k-z] = phy_struct->ce_mag[i][k-(z-1)] - frac_mag;
                            phy_struct->ce_ang[i][k-z] = phy_struct->ce_ang[i][k-(z-1)] - frac_ang;
                        }
                    }

                    // Linearly interpolate before 1st CRS
                    if(j == 1)
                    {
                        for(z=1; z<((v[i] + v_shift)%6)+1; z++)
                        {
                            phy_struct->ce_mag[i][k-6-z] = phy_struct->ce_mag[i][k-6-(z-1)] - frac_mag;
                            phy_struct->ce_ang[i][k-6-z] = phy_struct->ce_ang[i][k-6-(z-1)] - frac_ang;
                        }
                    }
                }

                // Linearly interpolate after last CRS
                for(z=1; z<(5-(v[i] + v_shift)%6)+1; z++)
                {
                    phy_struct->ce_mag[i][k+z] = phy_struct->ce_mag[i][k+(z-1)] - frac_mag;
                    phy_struct->ce_ang[i][k+z] = phy_struct->ce_ang[i][k+(z-1)] - frac_ang;
                }
            }

            // Linearly interpolate between symbols to construct all channel estimates
            if(N_sym == 3)
            {
                for(j=0; j<N_rb_dl*LIBLTE_PHY_N_SC_RB_NORMAL_CP; j++)
                {
                    // Construct symbol 1 and 8 channel estimates directly
                    subframe->ce_re[p][1][j] = phy_struct->ce_mag[0][j]*cosf(phy_struct->ce_ang[0][j]);
                    subframe->ce_im[p][1][j] = phy_struct->ce_mag[0][j]*sinf(phy_struct->ce_ang[0][j]);
                    subframe->ce_re[p][8][j] = phy_struct->ce_mag[1][j]*cosf(phy_struct->ce_ang[1][j]);
                    subframe->ce_im[p][8][j] = phy_struct->ce_mag[1][j]*sinf(phy_struct->ce_ang[1][j]);

                    // Interpolate for symbol 2, 3, 4, 5, 6, and 7 channel estimates
                    frac_mag = (phy_struct->ce_mag[1][j] - phy_struct->ce_mag[0][j])/7;
                    frac_ang = (phy_struct->ce_ang[1][j] - phy_struct->ce_ang[0][j]);
                    if(frac_ang >= M_PI)
                    {
                        // Wrap angle
                        frac_ang -= 2*M_PI;
                    }else if(frac_ang <= -M_PI){
                        // Wrap angle
                        frac_ang += 2*M_PI;
                    }
                    frac_ang /= 7;
                    ce_mag    = phy_struct->ce_mag[1][j];
                    ce_ang    = phy_struct->ce_ang[1][j];
                    for(z=7; z>1; z--)
                    {
                        ce_mag                   -= frac_mag;
                        ce_ang                   -= frac_ang;
                        subframe->ce_re[p][z][j]  = ce_mag*cosf(ce_ang);
                        subframe->ce_im[p][z][j]  = ce_mag*sinf(ce_ang);
                    }

                    // Interpolate for symbol 0 channel estimate
                    // FIXME: Use previous slot to do this correctly
                    ce_mag                   = phy_struct->ce_mag[0][j] - frac_mag;
                    ce_ang                   = phy_struct->ce_ang[0][j] - frac_ang;
                    subframe->ce_re[p][0][j] = ce_mag*cosf(ce_ang);
                    subframe->ce_im[p][0][j] = ce_mag*sinf(ce_ang);

                    // Interpolate for symbol 9, 10, 11, 12, and 13 channel estimates
                    frac_mag = (phy_struct->ce_mag[2][j] - phy_struct->ce_mag[1][j])/7;
                    frac_ang = (phy_struct->ce_ang[2][j] - phy_struct->ce_ang[1][j]);
                    if(frac_ang >= M_PI)
                    {
                        // Wrap angle
                        frac_ang -= 2*M_PI;
                    }else if(frac_ang <= -M_PI){
                        // Wrap angle
                        frac_ang += 2*M_PI;
                    }
                    frac_ang /= 7;
                    ce_mag    = phy_struct->ce_mag[2][j] - frac_mag;
                    ce_ang    = phy_struct->ce_ang[2][j] - frac_ang;
                    for(z=13; z>8; z--)
                    {
                        ce_mag                   -= frac_mag;
                        ce_ang                   -= frac_ang;
                        subframe->ce_re[p][z][j]  = ce_mag*cosf(ce_ang);
                        subframe->ce_im[p][z][j]  = ce_mag*sinf(ce_ang);
                    }
                }
            }else{
                for(j=0; j<N_rb_dl*LIBLTE_PHY_N_SC_RB_NORMAL_CP; j++)
                {
                    // Construct symbol 0, 4, 7, and 11 channel estimates directly
                    subframe->ce_re[p][0][j]  = phy_struct->ce_mag[0][j]*cosf(phy_struct->ce_ang[0][j]);
                    subframe->ce_im[p][0][j]  = phy_struct->ce_mag[0][j]*sinf(phy_struct->ce_ang[0][j]);
                    subframe->ce_re[p][4][j]  = phy_struct->ce_mag[1][j]*cosf(phy_struct->ce_ang[1][j]);
                    subframe->ce_im[p][4][j]  = phy_struct->ce_mag[1][j]*sinf(phy_struct->ce_ang[1][j]);
                    subframe->ce_re[p][7][j]  = phy_struct->ce_mag[2][j]*cosf(phy_struct->ce_ang[2][j]);
                    subframe->ce_im[p][7][j]  = phy_struct->ce_mag[2][j]*sinf(phy_struct->ce_ang[2][j]);
                    subframe->ce_re[p][11][j] = phy_struct->ce_mag[3][j]*cosf(phy_struct->ce_ang[3][j]);
                    subframe->ce_im[p][11][j] = phy_struct->ce_mag[3][j]*sinf(phy_struct->ce_ang[3][j]);

                    // Interpolate for symbol 1, 2, and 3 channel estimates
                    frac_mag = (phy_struct->ce_mag[1][j] - phy_struct->ce_mag[0][j])/4;
                    frac_ang = (phy_struct->ce_ang[1][j] - phy_struct->ce_ang[0][j]);
                    if(frac_ang >= M_PI)
                    {
                        // Wrap phase
                        frac_ang -= 2*M_PI;
                    }else if(frac_ang <= -M_PI){
                        // Wrap phase
                        frac_ang += 2*M_PI;
                    }
                    frac_ang /= 4;
                    ce_mag    = phy_struct->ce_mag[1][j];
                    ce_ang    = phy_struct->ce_ang[1][j];
                    for(z=3; z>0; z--)
                    {
                        ce_mag                   -= frac_mag;
                        ce_ang                   -= frac_ang;
                        subframe->ce_re[p][z][j]  = ce_mag*cosf(ce_ang);
                        subframe->ce_im[p][z][j]  = ce_mag*sinf(ce_ang);
                    }

                    // Interpolate for symbol 5 and 6 channel estimates
                    frac_mag = (phy_struct->ce_mag[2][j] - phy_struct->ce_mag[1][j])/3;
                    frac_ang = (phy_struct->ce_ang[2][j] - phy_struct->ce_ang[1][j]);
                    if(frac_ang >= M_PI)
                    {
                        // Wrap angle
                        frac_ang -= 2*M_PI;
                    }else if(frac_ang <= -M_PI){
                        // Wrap angle
                        frac_ang += 2*M_PI;
                    }
                    frac_ang /= 3;
                    ce_mag    = phy_struct->ce_mag[2][j];
                    ce_ang    = phy_struct->ce_ang[2][j];
                    for(z=6; z>4; z--)
                    {
                        ce_mag                   -= frac_mag;
                        ce_ang                   -= frac_ang;
                        subframe->ce_re[p][z][j]  = ce_mag*cosf(ce_ang);
                        subframe->ce_im[p][z][j]  = ce_mag*sinf(ce_ang);
                    }

                    // Interpolate for symbol 8, 9, and 10 channel estimates
                    frac_mag = (phy_struct->ce_mag[3][j] - phy_struct->ce_mag[2][j])/4;
                    frac_ang = (phy_struct->ce_ang[3][j] - phy_struct->ce_ang[2][j]);
                    if(frac_ang >= M_PI)
                    {
                        // Wrap angle
                        frac_ang -= 2*M_PI;
                    }else if(frac_ang <= -M_PI){
                        // Wrap angle
                        frac_ang += 2*M_PI;
                    }
                    frac_ang /= 4;
                    ce_mag    = phy_struct->ce_mag[3][j];
                    ce_ang    = phy_struct->ce_ang[3][j];
                    for(z=10; z>7; z--)
                    {
                        ce_mag                   -= frac_mag;
                        ce_ang                   -= frac_ang;
                        subframe->ce_re[p][z][j]  = ce_mag*cosf(ce_ang);
                        subframe->ce_im[p][z][j]  = ce_mag*sinf(ce_ang);
                    }

                    // Interpolate for symbol 12 and 13 channel estimates
                    frac_mag = (phy_struct->ce_mag[4][j] - phy_struct->ce_mag[3][j])/3;
                    frac_ang = (phy_struct->ce_ang[4][j] - phy_struct->ce_ang[3][j]);
                    if(frac_ang >= M_PI)
                    {
                        // Wrap angle
                        frac_ang -= 2*M_PI;
                    }else if(frac_ang <= -M_PI){
                        // Wrap angle
                        frac_ang += 2*M_PI;
                    }
                    frac_ang /= 3;
                    ce_mag    = phy_struct->ce_mag[4][j];
                    ce_ang    = phy_struct->ce_ang[4][j];
                    for(z=13; z>11; z--)
                    {
                        ce_mag                   -= frac_mag;
                        ce_ang                   -= frac_ang;
                        subframe->ce_re[p][z][j]  = ce_mag*cosf(ce_ang);
                        subframe->ce_im[p][z][j]  = ce_mag*sinf(ce_ang);
                    }
                }
            }
        }

        err = LIBLTE_SUCCESS;
    }

    return(err);
}

/*********************************************************************
    Name: liblte_phy_bch_channel_decode

    Description: Demodulates and decodes the Physical Broadcast
                 Channel

    Document Reference: 3GPP TS 36.211 v10.1.0 section 6.6
*********************************************************************/
LIBLTE_ERROR_ENUM liblte_phy_bch_channel_decode(LIBLTE_PHY_STRUCT          *phy_struct,
                                                LIBLTE_PHY_SUBFRAME_STRUCT *subframe,
                                                uint32                      N_id_cell,
                                                uint8                      *N_ant,
                                                uint8                      *out_bits,
                                                uint32                     *N_out_bits,
                                                uint8                      *offset)
{
    LIBLTE_ERROR_ENUM err = LIBLTE_ERROR_INVALID_INPUTS;
    uint32            i;
    uint32            j;
    uint32            p;
    uint32            idx;
    uint32            M_layer_symb;
    uint32            M_symb;
    uint32            N_bits;

    if(phy_struct != NULL &&
       subframe   != NULL &&
       N_id_cell  >= 0    &&
       N_id_cell  <= 503  &&
       N_ant      != NULL &&
       out_bits   != NULL &&
       N_out_bits != NULL &&
       offset     != NULL)
    {
        err = LIBLTE_ERROR_DECODE_FAIL;

        // Unmap PBCH and channel estimates from resource elements
        idx = 0;
        for(i=0; i<72; i++) // FIXME: This is assuming 1.4MHz
        {
            if((N_id_cell % 3) != (i % 3))
            {
                phy_struct->bch_y_est_re[idx]    = subframe->symb_re[7][i];
                phy_struct->bch_y_est_im[idx]    = subframe->symb_im[7][i];
                phy_struct->bch_y_est_re[idx+48] = subframe->symb_re[8][i];
                phy_struct->bch_y_est_im[idx+48] = subframe->symb_im[8][i];
                for(p=0; p<4; p++)
                {
                    phy_struct->bch_c_est_re[p][idx]    = subframe->ce_re[p][7][i];
                    phy_struct->bch_c_est_im[p][idx]    = subframe->ce_im[p][7][i];
                    phy_struct->bch_c_est_re[p][idx+48] = subframe->ce_re[p][8][i];
                    phy_struct->bch_c_est_im[p][idx+48] = subframe->ce_im[p][8][i];
                }
                idx++;
            }
            phy_struct->bch_y_est_re[i+96]  = subframe->symb_re[9][i];
            phy_struct->bch_y_est_im[i+96]  = subframe->symb_im[9][i];
            phy_struct->bch_y_est_re[i+168] = subframe->symb_re[10][i];
            phy_struct->bch_y_est_im[i+168] = subframe->symb_im[10][i];
            for(p=0; p<4; p++)
            {
                phy_struct->bch_c_est_re[p][i+96]  = subframe->ce_re[p][9][i];
                phy_struct->bch_c_est_im[p][i+96]  = subframe->ce_im[p][9][i];
                phy_struct->bch_c_est_re[p][i+168] = subframe->ce_re[p][10][i];
                phy_struct->bch_c_est_im[p][i+168] = subframe->ce_im[p][10][i];
            }
        }

        // Generate the scrambling sequence
        generate_prs_c(N_id_cell, 1920, phy_struct->bch_c);

        // Try decoding with 1, 2, and 4 antennas
        for(p=1; p<5; p++)
        {
            if(p != 3)
            {
                pre_decoder_and_matched_filter(phy_struct->bch_y_est_re,
                                               phy_struct->bch_y_est_im,
                                               phy_struct->bch_c_est_re[0],
                                               phy_struct->bch_c_est_im[0],
                                               240,
                                               240,
                                               p,
                                               LIBLTE_PHY_PRE_CODER_TYPE_TX_DIVERSITY,
                                               phy_struct->bch_x_re,
                                               phy_struct->bch_x_im,
                                               &M_layer_symb);
                layer_demapper(phy_struct->bch_x_re,
                               phy_struct->bch_x_im,
                               M_layer_symb,
                               p,
                               1,
                               LIBLTE_PHY_PRE_CODER_TYPE_TX_DIVERSITY,
                               phy_struct->bch_d_re,
                               phy_struct->bch_d_im,
                               &M_symb);
                modulation_demapper(phy_struct->bch_d_re,
                                    phy_struct->bch_d_im,
                                    M_symb,
                                    LIBLTE_PHY_MODULATION_TYPE_QPSK,
                                    phy_struct->bch_soft_bits,
                                    &N_bits);

                // Try decoding at each offset
                *N_ant = 0;
                for(i=0; i<4; i++)
                {
                    for(j=0; j<1920; j++)
                    {
                        phy_struct->bch_descramb_bits[j] = RX_NULL_BIT;
                    }
                    for(j=0; j<480; j++)
                    {
                        phy_struct->bch_descramb_bits[(i*480)+j] = (float)phy_struct->bch_soft_bits[j]*(1-2*(float)phy_struct->bch_c[(i*480)+j]);
                    }
                    if(LIBLTE_SUCCESS == bch_channel_decode(phy_struct,
                                                            phy_struct->bch_descramb_bits,
                                                            1920,
                                                            N_ant,
                                                            out_bits,
                                                            N_out_bits))
                    {
                        *offset = i;
                        break;
                    }
                }
                if(*N_ant != 0)
                {
                    err = LIBLTE_SUCCESS;
                    break;
                }
            }
        }
    }

    return(err);
}

/*********************************************************************
    Name: liblte_phy_pdcch_channel_decode

    Description: Demodulates and decodes all of the Physical Downlink
                 Control Channel (PCFICH, PHICH, and PDCCH)

    Document Reference: 3GPP TS 36.211 v10.1.0 sections 6.7, 6.8, and
                        6.9
*********************************************************************/
LIBLTE_ERROR_ENUM liblte_phy_pdcch_channel_decode(LIBLTE_PHY_STRUCT              *phy_struct,
                                                  LIBLTE_PHY_SUBFRAME_STRUCT     *subframe,
                                                  uint32                          N_id_cell,
                                                  uint8                           N_ant,
                                                  uint32                          N_sc_rb,
                                                  uint32                          N_rb_dl,
                                                  float                           phich_res,
                                                  LIBLTE_RRC_PHICH_DURATION_ENUM  phich_dur,
                                                  LIBLTE_PHY_PCFICH_STRUCT       *pcfich,
                                                  LIBLTE_PHY_PHICH_STRUCT        *phich,
                                                  LIBLTE_PHY_PDCCH_STRUCT        *pdcch)
{
    LIBLTE_ERROR_ENUM err = LIBLTE_ERROR_INVALID_INPUTS;
    float             cfi_n[4];
    uint32            cfi_k[4];
    uint32            i;
    uint32            j;
    uint32            k;
    uint32            p;
    uint32            idx;
    uint32            k_hat;
    uint32            c_init;
    uint32            M_layer_symb;
    uint32            M_symb;
    uint32            N_bits;
    uint32            k_prime;
    uint32            l_prime;
    uint32            m_prime;
    uint32            n_l_prime;
    uint32            dci_1a_size;
    uint32            dci_1c_size;
    uint32            n_hat[3];
    uint32            N_reg_rb;
    uint32            shift_idx;
    uint32            C_cc_sb;
    uint32            R_cc_sb;
    uint32            K_pi;
    uint32            phich_k[75];
    uint32            N_dummy;
    uint32            N_reg_cce;
    bool              valid_reg;

    if(phy_struct != NULL &&
       subframe   != NULL &&
       pcfich     != NULL &&
       phich      != NULL &&
       pdcch      != NULL)
    {
        // PCFICH
        // Calcualte resources, 3GPP TS 36.211 v10.1.0 section 6.7.4
        pcfich->N_reg = 4;
        k_hat         = (N_sc_rb/2)*(N_id_cell % (2*N_rb_dl));
        for(i=0; i<pcfich->N_reg; i++)
        {
            cfi_k[i] = (k_hat + (i*N_rb_dl/2)*N_sc_rb/2) % (N_rb_dl*N_sc_rb);
            cfi_n[i] = (cfi_k[i]/6) - 0.5;

            // Extract resource elements and channel estimate
            idx = 0;
            for(j=0; j<6; j++)
            {
                if((N_id_cell % 3) != (j % 3))
                {
                    phy_struct->pdcch_y_est_re[idx+(i*4)] = subframe->symb_re[0][cfi_k[i]+j];
                    phy_struct->pdcch_y_est_im[idx+(i*4)] = subframe->symb_im[0][cfi_k[i]+j];
                    for(p=0; p<N_ant; p++)
                    {
                        phy_struct->pdcch_c_est_re[p][idx+(i*4)] = subframe->ce_re[p][0][cfi_k[i]+j];
                        phy_struct->pdcch_c_est_im[p][idx+(i*4)] = subframe->ce_im[p][0][cfi_k[i]+j];
                    }
                    idx++;
                }
            }
        }
        // Decode, 3GPP TS 36.211 v10.1.0 section 6.7
        c_init = (((subframe->num + 1)*(2*N_id_cell + 1)) << 9) + N_id_cell;
        generate_prs_c(c_init, 32, phy_struct->pdcch_c);
        pre_decoder_and_matched_filter(phy_struct->pdcch_y_est_re,
                                       phy_struct->pdcch_y_est_im,
                                       phy_struct->pdcch_c_est_re[0],
                                       phy_struct->pdcch_c_est_im[0],
                                       288,
                                       16,
                                       N_ant,
                                       LIBLTE_PHY_PRE_CODER_TYPE_TX_DIVERSITY,
                                       phy_struct->pdcch_x_re,
                                       phy_struct->pdcch_x_im,
                                       &M_layer_symb);
        layer_demapper(phy_struct->pdcch_x_re,
                       phy_struct->pdcch_x_im,
                       M_layer_symb,
                       N_ant,
                       1,
                       LIBLTE_PHY_PRE_CODER_TYPE_TX_DIVERSITY,
                       phy_struct->pdcch_d_re,
                       phy_struct->pdcch_d_im,
                       &M_symb);
        modulation_demapper(phy_struct->pdcch_d_re,
                            phy_struct->pdcch_d_im,
                            M_symb,
                            LIBLTE_PHY_MODULATION_TYPE_QPSK,
                            phy_struct->pdcch_soft_bits,
                            &N_bits);
        for(i=0; i<N_bits; i++)
        {
            phy_struct->pdcch_descramb_bits[i] = (float)phy_struct->pdcch_soft_bits[i]*(1-2*(float)phy_struct->pdcch_c[i]);
        }
        if(LIBLTE_SUCCESS != cfi_channel_decode(phy_struct,
                                                phy_struct->pdcch_descramb_bits,
                                                N_bits,
                                                &pcfich->cfi))
        {
            err = LIBLTE_ERROR_INVALID_CRC;
            return(err);
        }

        // PHICH
        // Calculate resources, 3GPP TS 36.211 v10.1.0 section 6.9
        phich->N_group = (uint32)ceilf((float)phich_res*((float)N_rb_dl/(float)8)); // FIXME: Only handles normal CP
        phich->N_reg   = phich->N_group*3;
        // Step 4
        m_prime = 0;
        idx     = 0;
        while(m_prime < phich->N_group)
        {
            if(phich_dur == LIBLTE_RRC_PHICH_DURATION_NORMAL)
            {
                // Step 7
                l_prime = 0;
                // Step 1, 2, and 3
                n_l_prime = N_rb_dl*2 - pcfich->N_reg;
                // Step 8
                for(i=0; i<3; i++)
                {
                    n_hat[i] = (N_id_cell + m_prime + i*n_l_prime/3) % n_l_prime;
                }
                // Avoid PCFICH
                for(i=0; i<pcfich->N_reg; i++)
                {
                    for(j=0; j<3; j++)
                    {
                        if(n_hat[j] > cfi_n[i])
                        {
                            n_hat[j]++;
                        }
                    }
                }
                // Step 5
                for(i=0; i<3; i++)
                {
                    phich_k[idx+i] = n_hat[i]*6;
                    // FIXME: Not currently implementing step 6
                }
                idx += 3;
            }else{
                // FIXME: Not handling extended PHICH duration
                err = LIBLTE_ERROR_INVALID_INPUTS;
                return(err);
            }
            // Step 9
            m_prime++;
        }

        // PDCCH
        // Calculate number of symbols, 3GPP TS 36.211 v10.1.0 section 6.7
        pdcch->N_symbs = pcfich->cfi;
        if(N_rb_dl <= 10)
        {
            pdcch->N_symbs++;
        }
        // Calculate resources, 3GPP TS 36.211 v10.1.0 section 6.8.1
        N_reg_rb     = 3;
        pdcch->N_reg = pdcch->N_symbs*(N_rb_dl*N_reg_rb) - N_rb_dl - pcfich->N_reg - phich->N_reg;
        if(N_ant == 4)
        {
            // Remove CRS
            pdcch->N_reg -= N_rb_dl;
        }
        pdcch->N_cce = pdcch->N_reg/9;
        pdcch->N_reg = pdcch->N_cce*9;
        // Extract resource elements and channel estimate, 3GPP TS 36.211 v10.1.0 section 6.8.5
        // Step 1 and 2
        m_prime = 0;
        k_prime = 0;
        // Step 10
        while(k_prime < (N_rb_dl*N_sc_rb))
        {
            // Step 3
            l_prime = 0;
            // Step 8
            while(l_prime < pdcch->N_symbs)
            {
                if(l_prime == 0)
                {
                    // Step 4
                    // Avoid PCFICH and PHICH
                    valid_reg = true;
                    for(i=0; i<pcfich->N_reg; i++)
                    {
                        if(k_prime == cfi_k[i])
                        {
                            valid_reg = false;
                        }
                    }
                    for(i=0; i<phich->N_reg; i++)
                    {
                        if(k_prime == phich_k[i])
                        {
                            valid_reg = false;
                        }
                    }
                    if((k_prime % 6) == 0 && valid_reg == true)
                    {
                        if(m_prime < pdcch->N_reg)
                        {
                            // Step 5
                            idx = 0;
                            for(i=0; i<6; i++)
                            {
                                // Avoid CRS
                                if((N_id_cell % 3) != (i % 3))
                                {
                                    phy_struct->pdcch_reg_y_est_re[m_prime][idx] = subframe->symb_re[l_prime][k_prime+i];
                                    phy_struct->pdcch_reg_y_est_im[m_prime][idx] = subframe->symb_im[l_prime][k_prime+i];
                                    for(p=0; p<N_ant; p++)
                                    {
                                        phy_struct->pdcch_reg_c_est_re[p][m_prime][idx] = subframe->ce_re[p][l_prime][k_prime+i];
                                        phy_struct->pdcch_reg_c_est_im[p][m_prime][idx] = subframe->ce_im[p][l_prime][k_prime+i];
                                    }
                                    idx++;
                                }
                            }
                            // Step 6
                            m_prime++;
                        }
                    }
                }else if(l_prime == 1 && N_ant == 4){
                    // Step 4
                    if((k_prime % 6) == 0)
                    {
                        if(m_prime < pdcch->N_reg)
                        {
                            // Step 5
                            idx = 0;
                            for(i=0; i<6; i++)
                            {
                                // Avoid CRS
                                if((N_id_cell % 3) != (i % 3))
                                {
                                    phy_struct->pdcch_reg_y_est_re[m_prime][idx] = subframe->symb_re[l_prime][k_prime+i];
                                    phy_struct->pdcch_reg_y_est_im[m_prime][idx] = subframe->symb_im[l_prime][k_prime+i];
                                    for(p=0; p<N_ant; p++)
                                    {
                                        phy_struct->pdcch_reg_c_est_re[p][m_prime][idx] = subframe->ce_re[p][l_prime][k_prime+i];
                                        phy_struct->pdcch_reg_c_est_im[p][m_prime][idx] = subframe->ce_im[p][l_prime][k_prime+i];
                                    }
                                    idx++;
                                }
                            }
                            // Step 6
                            m_prime++;
                        }
                    }
                }else{
                    // Step 4
                    if((k_prime % 4) == 0)
                    {
                        if(m_prime < pdcch->N_reg)
                        {
                            // Step 5
                            for(i=0; i<4; i++)
                            {
                                phy_struct->pdcch_reg_y_est_re[m_prime][i] = subframe->symb_re[l_prime][k_prime+i];
                                phy_struct->pdcch_reg_y_est_im[m_prime][i] = subframe->symb_im[l_prime][k_prime+i];
                                for(p=0; p<N_ant; p++)
                                {
                                    phy_struct->pdcch_reg_c_est_re[p][m_prime][i] = subframe->ce_re[p][l_prime][k_prime+i];
                                    phy_struct->pdcch_reg_c_est_im[p][m_prime][i] = subframe->ce_im[p][l_prime][k_prime+i];
                                }
                            }
                            // Step 6
                            m_prime++;
                        }
                    }
                }
                // Step 7
                l_prime++;
            }
            // Step 9
            k_prime++;
        }
        // Undo cyclic shift of the REGs
        for(i=0; i<pdcch->N_reg; i++)
        {
            shift_idx = (i+N_id_cell) % pdcch->N_reg;
            for(j=0; j<4; j++)
            {
                phy_struct->pdcch_shift_y_est_re[shift_idx][j] = phy_struct->pdcch_reg_y_est_re[i][j];
                phy_struct->pdcch_shift_y_est_im[shift_idx][j] = phy_struct->pdcch_reg_y_est_im[i][j];
                for(p=0; p<N_ant; p++)
                {
                    phy_struct->pdcch_shift_c_est_re[p][shift_idx][j] = phy_struct->pdcch_reg_c_est_re[p][i][j];
                    phy_struct->pdcch_shift_c_est_im[p][shift_idx][j] = phy_struct->pdcch_reg_c_est_im[p][i][j];
                }
            }
        }
        // Undo permutation of the REGs, 3GPP TS 36.212 v10.1.0 section 5.1.4.2.1
        for(i=0; i<pdcch->N_reg; i++)
        {
            phy_struct->pdcch_reg_vec[i] = i;
        }
        // In order to recreate circular buffer, a dummy block must be
        // sub block interleaved to determine where NULL bits are to be
        // inserted
        // Step 1
        C_cc_sb = 32;
        // Step 2
        R_cc_sb = 0;
        while(pdcch->N_reg > (C_cc_sb*R_cc_sb))
        {
            R_cc_sb++;
        }
        // Step 3
        if(pdcch->N_reg < (C_cc_sb*R_cc_sb))
        {
            N_dummy = C_cc_sb*R_cc_sb - pdcch->N_reg;
        }else{
            N_dummy = 0;
        }
        for(i=0; i<N_dummy; i++)
        {
            phy_struct->ruc_tmp[i] = RX_NULL_BIT;
        }
        for(i=N_dummy; i<pdcch->N_reg; i++)
        {
            phy_struct->ruc_tmp[i] = 0;
        }
        idx = 0;
        for(i=0; i<R_cc_sb; i++)
        {
            for(j=0; j<C_cc_sb; j++)
            {
                phy_struct->ruc_sb_mat[i][j] = phy_struct->ruc_tmp[idx++];
            }
        }
        // Step 4
        for(i=0; i<R_cc_sb; i++)
        {
            for(j=0; j<C_cc_sb; j++)
            {
                phy_struct->ruc_sb_perm_mat[i][j] = phy_struct->ruc_sb_mat[i][IC_PERM_CC[j]];
            }
        }
        // Step 5
        idx = 0;
        for(j=0; j<C_cc_sb; j++)
        {
            for(i=0; i<R_cc_sb; i++)
            {
                phy_struct->ruc_v[0][idx++] = phy_struct->ruc_sb_perm_mat[i][j];
            }
        }
        // Recreate circular buffer
        K_pi = R_cc_sb*C_cc_sb;
        k    = 0;
        j    = 0;
        while(k < pdcch->N_reg)
        {
            if(phy_struct->ruc_v[0][j%K_pi] != RX_NULL_BIT)
            {
                phy_struct->ruc_v[0][j%K_pi] = phy_struct->pdcch_reg_vec[k++];
            }
            j++;
        }
        // Sub block deinterleaving
        // Step 5
        idx = 0;
        for(j=0; j<C_cc_sb; j++)
        {
            for(i=0; i<R_cc_sb; i++)
            {
                phy_struct->ruc_sb_perm_mat[i][j] = phy_struct->ruc_v[0][idx++];
            }
        }
        // Step 4
        for(i=0; i<R_cc_sb; i++)
        {
            for(j=0; j<C_cc_sb; j++)
            {
                phy_struct->ruc_sb_mat[i][IC_PERM_CC[j]] = phy_struct->ruc_sb_perm_mat[i][j];
            }
        }
        // Step 3
        idx = 0;
        for(i=0; i<R_cc_sb; i++)
        {
            for(j=0; j<C_cc_sb; j++)
            {
                phy_struct->ruc_tmp[idx++] = phy_struct->ruc_sb_mat[i][j];
            }
        }
        for(i=0; i<pdcch->N_reg; i++)
        {
            for(j=0; j<4; j++)
            {
                phy_struct->pdcch_perm_y_est_re[i][j] = phy_struct->pdcch_shift_y_est_re[(uint32)phy_struct->ruc_tmp[N_dummy+i]][j];
                phy_struct->pdcch_perm_y_est_im[i][j] = phy_struct->pdcch_shift_y_est_im[(uint32)phy_struct->ruc_tmp[N_dummy+i]][j];
                for(p=0; p<N_ant; p++)
                {
                    phy_struct->pdcch_perm_c_est_re[p][i][j] = phy_struct->pdcch_shift_c_est_re[p][(uint32)phy_struct->ruc_tmp[N_dummy+i]][j];
                    phy_struct->pdcch_perm_c_est_im[p][i][j] = phy_struct->pdcch_shift_c_est_im[p][(uint32)phy_struct->ruc_tmp[N_dummy+i]][j];
                }
            }
        }
        // Construct CCEs
        N_reg_cce = 9;
        for(i=0; i<pdcch->N_cce; i++)
        {
            for(j=0; j<N_reg_cce; j++)
            {
                for(k=0; k<4; k++)
                {
                    phy_struct->pdcch_cce_y_est_re[i][j*4+k] = phy_struct->pdcch_perm_y_est_re[i*N_reg_cce+j][k];
                    phy_struct->pdcch_cce_y_est_im[i][j*4+k] = phy_struct->pdcch_perm_y_est_im[i*N_reg_cce+j][k];
                    for(p=0; p<N_ant; p++)
                    {
                        phy_struct->pdcch_cce_c_est_re[p][i][j*4+k] = phy_struct->pdcch_perm_c_est_re[p][i*N_reg_cce+j][k];
                        phy_struct->pdcch_cce_c_est_im[p][i][j*4+k] = phy_struct->pdcch_perm_c_est_im[p][i*N_reg_cce+j][k];
                    }
                }
            }
        }

        // Generate the scrambling sequence
        c_init = (subframe->num << 9) + N_id_cell;
        generate_prs_c(c_init, 1152, phy_struct->pdcch_c);

        // Determine the size of DCI 1A and 1C FIXME: Clean this up
        if(N_rb_dl == 6)
        {
            dci_1a_size = 21;
            dci_1c_size = 9;
        }else if(N_rb_dl == 15){
            dci_1a_size = 22;
            dci_1c_size = 11;
        }else if(N_rb_dl == 25){
            dci_1a_size = 25;
            dci_1c_size = 13;
        }else if(N_rb_dl == 50){
            dci_1a_size = 27;
            dci_1c_size = 13;
        }else if(N_rb_dl == 75){
            dci_1a_size = 27;
            dci_1c_size = 14;
        }else{ // N_rb_dl == 100
            dci_1a_size = 28;
            dci_1c_size = 15;
        }

        // Try decoding DCI 1A and 1C for SI in the common search space
        pdcch->N_alloc = 0;
        for(i=0; i<4; i++)
        {
            idx = 0;
            for(j=0; j<4; j++)
            {
                for(k=0; k<36; k++)
                {
                    phy_struct->pdcch_y_est_re[idx] = phy_struct->pdcch_cce_y_est_re[i*4+j][k];
                    phy_struct->pdcch_y_est_im[idx] = phy_struct->pdcch_cce_y_est_im[i*4+j][k];
                    for(p=0; p<N_ant; p++)
                    {
                        phy_struct->pdcch_c_est_re[p][idx] = phy_struct->pdcch_cce_c_est_re[p][i*4+j][k];
                        phy_struct->pdcch_c_est_im[p][idx] = phy_struct->pdcch_cce_c_est_im[p][i*4+j][k];
                    }
                    idx++;
                }
            }

            pre_decoder_and_matched_filter(phy_struct->pdcch_y_est_re,
                                           phy_struct->pdcch_y_est_im,
                                           phy_struct->pdcch_c_est_re[0],
                                           phy_struct->pdcch_c_est_im[0],
                                           288,
                                           idx,
                                           N_ant,
                                           LIBLTE_PHY_PRE_CODER_TYPE_TX_DIVERSITY,
                                           phy_struct->pdcch_x_re,
                                           phy_struct->pdcch_x_im,
                                           &M_layer_symb);
            layer_demapper(phy_struct->pdcch_x_re,
                           phy_struct->pdcch_x_im,
                           M_layer_symb,
                           N_ant,
                           1,
                           LIBLTE_PHY_PRE_CODER_TYPE_TX_DIVERSITY,
                           phy_struct->pdcch_d_re,
                           phy_struct->pdcch_d_im,
                           &M_symb);
            modulation_demapper(phy_struct->pdcch_d_re,
                                phy_struct->pdcch_d_im,
                                M_symb,
                                LIBLTE_PHY_MODULATION_TYPE_QPSK,
                                phy_struct->pdcch_soft_bits,
                                &N_bits);
            for(j=0; j<N_bits; j++)
            {
                phy_struct->pdcch_descramb_bits[j] = (float)phy_struct->pdcch_soft_bits[j]*(1-2*(float)phy_struct->pdcch_c[i*288+j]);
            }
            if(pdcch->N_alloc <  LIBLTE_PHY_PDCCH_MAX_ALLOC &&
               LIBLTE_SUCCESS == dci_channel_decode(phy_struct,
                                                    phy_struct->pdcch_descramb_bits,
                                                    N_bits,
                                                    LIBLTE_PHY_SI_RNTI,
                                                    0,
                                                    phy_struct->pdcch_dci,
                                                    dci_1a_size))
            {
                err = LIBLTE_SUCCESS;
                dci_1a_unpack(phy_struct->pdcch_dci,
                              dci_1a_size,
                              LIBLTE_PHY_DCI_CA_NOT_PRESENT,
                              LIBLTE_PHY_SI_RNTI,
                              N_rb_dl,
                              N_ant,
                              &pdcch->alloc[pdcch->N_alloc++]);
            }
            if(pdcch->N_alloc <  LIBLTE_PHY_PDCCH_MAX_ALLOC &&
               LIBLTE_SUCCESS == dci_channel_decode(phy_struct,
                                                    phy_struct->pdcch_descramb_bits,
                                                    N_bits,
                                                    LIBLTE_PHY_SI_RNTI,
                                                    0,
                                                    phy_struct->pdcch_dci,
                                                    dci_1c_size))
            {
                printf("DCI 1C FOUND L = 4, %u\n", i);
            }
        }
        for(i=0; i<2; i++)
        {
            idx = 0;
            for(j=0; j<8; j++)
            {
                for(k=0; k<36; k++)
                {
                    phy_struct->pdcch_y_est_re[idx] = phy_struct->pdcch_cce_y_est_re[i*8+j][k];
                    phy_struct->pdcch_y_est_im[idx] = phy_struct->pdcch_cce_y_est_im[i*8+j][k];
                    for(p=0; p<N_ant; p++)
                    {
                        phy_struct->pdcch_c_est_re[p][idx] = phy_struct->pdcch_cce_c_est_re[p][i*8+j][k];
                        phy_struct->pdcch_c_est_im[p][idx] = phy_struct->pdcch_cce_c_est_im[p][i*8+j][k];
                    }
                    idx++;
                }
            }

            pre_decoder_and_matched_filter(phy_struct->pdcch_y_est_re,
                                           phy_struct->pdcch_y_est_im,
                                           phy_struct->pdcch_c_est_re[0],
                                           phy_struct->pdcch_c_est_im[0],
                                           288,
                                           idx,
                                           N_ant,
                                           LIBLTE_PHY_PRE_CODER_TYPE_TX_DIVERSITY,
                                           phy_struct->pdcch_x_re,
                                           phy_struct->pdcch_x_im,
                                           &M_layer_symb);
            layer_demapper(phy_struct->pdcch_x_re,
                           phy_struct->pdcch_x_im,
                           M_layer_symb,
                           N_ant,
                           1,
                           LIBLTE_PHY_PRE_CODER_TYPE_TX_DIVERSITY,
                           phy_struct->pdcch_d_re,
                           phy_struct->pdcch_d_im,
                           &M_symb);
            modulation_demapper(phy_struct->pdcch_d_re,
                                phy_struct->pdcch_d_im,
                                M_symb,
                                LIBLTE_PHY_MODULATION_TYPE_QPSK,
                                phy_struct->pdcch_soft_bits,
                                &N_bits);
            for(j=0; j<N_bits; j++)
            {
                phy_struct->pdcch_descramb_bits[j] = (float)phy_struct->pdcch_soft_bits[j]*(1-2*(float)phy_struct->pdcch_c[i*576+j]);
            }
            if(pdcch->N_alloc <  LIBLTE_PHY_PDCCH_MAX_ALLOC &&
               LIBLTE_SUCCESS == dci_channel_decode(phy_struct,
                                                    phy_struct->pdcch_descramb_bits,
                                                    N_bits,
                                                    LIBLTE_PHY_SI_RNTI,
                                                    0,
                                                    phy_struct->pdcch_dci,
                                                    dci_1a_size))
            {
                err = LIBLTE_SUCCESS;
                dci_1a_unpack(phy_struct->pdcch_dci,
                              dci_1a_size,
                              LIBLTE_PHY_DCI_CA_NOT_PRESENT,
                              LIBLTE_PHY_SI_RNTI,
                              N_rb_dl,
                              N_ant,
                              &pdcch->alloc[pdcch->N_alloc++]);
            }
            if(pdcch->N_alloc <  LIBLTE_PHY_PDCCH_MAX_ALLOC &&
               LIBLTE_SUCCESS == dci_channel_decode(phy_struct,
                                                    phy_struct->pdcch_descramb_bits,
                                                    N_bits,
                                                    LIBLTE_PHY_SI_RNTI,
                                                    0,
                                                    phy_struct->pdcch_dci,
                                                    dci_1c_size))
            {
                printf("DCI 1C FOUND L = 8, %u\n", i);
            }
        }
    }

    return(err);
}

/*********************************************************************
    Name: liblte_phy_pdsch_channel_decode

    Description: Demodulates and decodes the Physical Downlink Shared
                 Channel

    Document Reference: 3GPP TS 36.211 v10.1.0 section 6.4
*********************************************************************/
LIBLTE_ERROR_ENUM liblte_phy_pdsch_channel_decode(LIBLTE_PHY_STRUCT          *phy_struct,
                                                  LIBLTE_PHY_SUBFRAME_STRUCT *subframe,
                                                  LIBLTE_PHY_PDCCH_STRUCT    *pdcch,
                                                  uint32                      N_id_cell,
                                                  uint8                       N_ant,
                                                  uint32                      N_sc_rb,
                                                  uint32                      N_rb_dl,
                                                  uint8                      *out_bits,
                                                  uint32                     *N_out_bits)
{
    LIBLTE_ERROR_ENUM err = LIBLTE_ERROR_INVALID_INPUTS;
    uint32            i;
    uint32            j;
    uint32            p;
    uint32            L;
    uint32            prb_idx;
    uint32            idx;
    uint32            c_init;
    uint32            M_layer_symb;
    uint32            M_symb;
    uint32            N_bits;

    if(phy_struct != NULL &&
       subframe   != NULL &&
       N_id_cell  >= 0    &&
       N_id_cell  <= 503  &&
       out_bits   != NULL &&
       N_out_bits != NULL)
    {
        err = LIBLTE_ERROR_DECODE_FAIL;

        // Extract resource elements and channel estimate 3GPP TS 36.211 v10.1.0 section 6.3.5
        // FIXME: Handle PBCH/PSS/SSS
        idx = 0;
        for(L=pdcch->N_symbs; L<14; L++)
        {
            for(i=0; i<N_rb_dl; i++)
            {
                for(prb_idx=0; prb_idx<pdcch->alloc[0].N_prb; prb_idx++)
                {
                    if(i == pdcch->alloc[0].prb[prb_idx])
                    {
                        for(j=0; j<N_sc_rb; j++)
                        {
                            if(N_ant           == 1 &&
                               (L % 7)         == 0 &&
                               (N_id_cell % 6) == (j % 6))
                            {
                                // Skip CRS
                            }else if(N_ant               == 1 &&
                                     (L % 7)             == 4 &&
                                     ((N_id_cell+3) % 6) == (j % 6)){
                                // Skip CRS
                            }else if((N_ant          == 2  ||
                                      N_ant          == 4) &&
                                     ((L % 7)        == 0  ||
                                      (L % 7)        == 4) &&
                                     (N_id_cell % 3) == (j % 3)){
                                // Skip CRS
                            }else if(N_ant           == 4 &&
                                     (L % 7)         == 1 &&
                                     (N_id_cell % 3) == (j % 3)){
                                // Skip CRS
                            }else{
                                phy_struct->pdsch_y_est_re[idx] = subframe->symb_re[L][i*N_sc_rb+j];
                                phy_struct->pdsch_y_est_im[idx] = subframe->symb_im[L][i*N_sc_rb+j];
                                for(p=0; p<N_ant; p++)
                                {
                                    phy_struct->pdsch_c_est_re[p][idx] = subframe->ce_re[p][L][i*N_sc_rb+j];
                                    phy_struct->pdsch_c_est_im[p][idx] = subframe->ce_im[p][L][i*N_sc_rb+j];
                                }
                                idx++;
                            }
                        }
                    }
                }
            }
        }
        pre_decoder_and_matched_filter(phy_struct->pdsch_y_est_re,
                                       phy_struct->pdsch_y_est_im,
                                       phy_struct->pdsch_c_est_re[0],
                                       phy_struct->pdsch_c_est_im[0],
                                       5000,
                                       idx,
                                       N_ant,
                                       pdcch->alloc[0].pre_coder_type,
                                       phy_struct->pdsch_x_re,
                                       phy_struct->pdsch_x_im,
                                       &M_layer_symb);
        layer_demapper(phy_struct->pdsch_x_re,
                       phy_struct->pdsch_x_im,
                       M_layer_symb,
                       N_ant,
                       pdcch->alloc[0].N_codewords,
                       pdcch->alloc[0].pre_coder_type,
                       phy_struct->pdsch_d_re,
                       phy_struct->pdsch_d_im,
                       &M_symb);
        modulation_demapper(phy_struct->pdsch_d_re,
                            phy_struct->pdsch_d_im,
                            M_symb,
                            pdcch->alloc[0].mod_type,
                            phy_struct->pdsch_soft_bits,
                            &N_bits);
        // FIXME: Only handling 1 codeword
        c_init = pdcch->alloc[0].rnti<<14 | 0<<13 | subframe->num<<9 | N_id_cell;
        generate_prs_c(c_init, N_bits, phy_struct->pdsch_c);
        for(i=0; i<N_bits; i++)
        {
            phy_struct->pdsch_descramb_bits[i] = (float)phy_struct->pdsch_soft_bits[i]*(1-2*(float)phy_struct->pdsch_c[i]);
        }
        if(LIBLTE_SUCCESS == dlsch_channel_decode(phy_struct,
                                                  phy_struct->pdsch_descramb_bits,
                                                  N_bits,
                                                  pdcch->alloc[0].tbs,
                                                  pdcch->alloc[0].tx_mode,
                                                  pdcch->alloc[0].rv_idx,
                                                  8,
                                                  250368, // FIXME: Using N_soft from a cat 1 UE (3GPP TS 36.306)
                                                  out_bits,
                                                  N_out_bits))
        {
            err = LIBLTE_SUCCESS;
        }
    }

    return(err);
}

/*******************************************************************************
                              LOCAL FUNCTIONS
*******************************************************************************/

/*********************************************************************
    Name: layer_mapper

    Description: Maps complex-valued modulation symbols onto one or
                 several layers

    Document Reference: 3GPP TS 36.211 v10.1.0 section 6.3.3

    NOTES: Currently only supports single antenna or TX diversity
*********************************************************************/
void layer_mapper(float                          *d_re,
                  float                          *d_im,
                  uint32                          M_symb,
                  uint32                          N_ant,
                  uint32                          N_codewords,
                  LIBLTE_PHY_PRE_CODER_TYPE_ENUM  type,
                  float                          *x_re,
                  float                          *x_im,
                  uint32                         *M_layer_symb)
{
    uint32 i;

    if(N_ant       == 1 &&
       N_codewords == 1)
    {
        // 3GPP TS 36.211 v10.1.0 section 6.3.3.1
        *M_layer_symb = M_symb;
        for(i=0; i<M_symb; i++)
        {
            x_re[i] = d_re[i];
            x_im[i] = d_im[i];
        }
    }else{
        if(LIBLTE_PHY_PRE_CODER_TYPE_TX_DIVERSITY == type)
        {
            // 3GPP TS 36.211 v10.1.0 section 6.3.3.3
            if(N_ant == 2)
            {
                *M_layer_symb = M_symb/2;
                for(i=0; i<*M_layer_symb; i++)
                {
//                    x_re[0][i] = d_re[2*i];
//                    x_im[0][i] = d_im[2*i];
//                    x_re[1][i] = d_re[2*i+1];
//                    x_im[1][i] = d_im[2*i+1];
                }
            }else{
                if((M_symb % 4) == 0)
                {
                    *M_layer_symb = M_symb/4;
                }else{
                    *M_layer_symb = (M_symb+2)/4;
                }
                for(i=0; i<*M_layer_symb; i++)
                {
//                    x_re[0][i] = d_re[4*i];
//                    x_im[0][i] = d_im[4*i];
//                    x_re[1][i] = d_re[4*i+1];
//                    x_im[1][i] = d_im[4*i+1];
//                    x_re[2][i] = d_re[4*i+2];
//                    x_im[2][i] = d_im[4*i+2];
//                    x_re[3][i] = d_re[4*i+3];
//                    x_im[3][i] = d_im[4*i+3];
                }
            }
        }else{
            // 3GPP TS 36.211 v10.1.0 section 6.3.3.2
            if(N_ant == 2)
            {
                if(N_codewords == 1)
                {
                    *M_layer_symb = M_symb/2;
                    for(i=0; i<*M_layer_symb; i++)
                    {
//                        x_re[0][i] = d_re[2*i];
//                        x_im[0][i] = d_im[2*i];
//                        x_re[1][i] = d_re[2*i+1];
//                        x_im[1][i] = d_im[2*i+1];
                    }
                }else{
                    *M_layer_symb = M_symb;
                    for(i=0; i<*M_layer_symb; i++)
                    {
//                        x_re[0][i] = d_re[0][i];
//                        x_im[0][i] = d_im[0][i];
//                        x_re[1][i] = d_re[1][i];
//                        x_im[1][i] = d_im[1][i];
                    }
                }
            }else if(N_ant == 3){
                if(N_codewords == 1)
                {
                    *M_layer_symb = M_symb/3;
                    for(i=0; i<*M_layer_symb; i++)
                    {
//                        x_re[0][i] = d_re[3*i];
//                        x_im[0][i] = d_im[3*i];
//                        x_re[1][i] = d_re[3*i+1];
//                        x_im[1][i] = d_im[3*i+1];
//                        x_re[2][i] = d_re[3*i+2];
//                        x_im[2][i] = d_im[3*i+2];
                    }
                }else{
                    *M_layer_symb = M_symb/2;
                    for(i=0; i<*M_layer_symb; i++)
                    {
//                        x_re[0][i] = d_re[0][i];
//                        x_im[0][i] = d_im[0][i];
//                        x_re[1][i] = d_re[1][2*i];
//                        x_im[1][i] = d_im[1][2*i];
//                        x_re[2][i] = d_re[1][2*i+1];
//                        x_im[2][i] = d_im[1][2*i+1];
                    }
                }
            }else if(N_ant == 4){
                if(N_codewords == 1)
                {
                    *M_layer_symb = M_symb/4;
                    for(i=0; i<*M_layer_symb; i++)
                    {
//                        x_re[0][i] = d_re[4*i];
//                        x_im[0][i] = d_im[4*i];
//                        x_re[1][i] = d_re[4*i+1];
//                        x_im[1][i] = d_im[4*i+1];
//                        x_re[2][i] = d_re[4*i+2];
//                        x_im[2][i] = d_im[4*i+2];
//                        x_re[3][i] = d_re[4*i+3];
//                        x_im[3][i] = d_im[4*i+3];
                    }
                }else{
                    *M_layer_symb = M_symb/2;
                    for(i=0; i<*M_layer_symb; i++)
                    {
//                        x_re[0][i] = d_re[0][2*i];
//                        x_im[0][i] = d_im[0][2*i];
//                        x_re[1][i] = d_re[0][2*i+1];
//                        x_im[1][i] = d_im[0][2*i+1];
//                        x_re[2][i] = d_re[1][2*i];
//                        x_im[2][i] = d_im[1][2*i];
//                        x_re[3][i] = d_re[1][2*i+1];
//                        x_im[3][i] = d_im[1][2*i+1];
                    }
                }
            }else if(N_ant == 5){
                *M_layer_symb = M_symb/3;
                for(i=0; i<*M_layer_symb; i++)
                {
//                    x_re[0][i] = d_re[0][2*i];
//                    x_im[0][i] = d_im[0][2*i];
//                    x_re[1][i] = d_re[0][2*i+1];
//                    x_im[1][i] = d_im[0][2*i+1];
//                    x_re[2][i] = d_re[1][3*i];
//                    x_im[2][i] = d_im[1][3*i];
//                    x_re[3][i] = d_re[1][3*i+1];
//                    x_im[3][i] = d_im[1][3*i+1];
//                    x_re[4][i] = d_re[1][3*i+2];
//                    x_im[4][i] = d_im[1][3*i+2];
                }
            }else if(N_ant == 6){
                *M_layer_symb = M_symb/3;
                for(i=0; i<*M_layer_symb; i++)
                {
//                    x_re[0][i] = d_re[0][3*i];
//                    x_im[0][i] = d_im[0][3*i];
//                    x_re[1][i] = d_re[0][3*i+1];
//                    x_im[1][i] = d_im[0][3*i+1];
//                    x_re[2][i] = d_re[0][3*i+2];
//                    x_im[2][i] = d_im[0][3*i+2];
//                    x_re[3][i] = d_re[1][3*i];
//                    x_im[3][i] = d_im[1][3*i];
//                    x_re[4][i] = d_re[1][3*i+1];
//                    x_im[4][i] = d_im[1][3*i+1];
//                    x_re[5][i] = d_re[1][3*i+2];
//                    x_im[5][i] = d_im[1][3*i+2];
                }
            }else if(N_ant == 7){
                *M_layer_symb = M_symb/4;
                for(i=0; i<*M_layer_symb; i++)
                {
//                    x_re[0][i] = d_re[0][3*i];
//                    x_im[0][i] = d_im[0][3*i];
//                    x_re[1][i] = d_re[0][3*i+1];
//                    x_im[1][i] = d_im[0][3*i+1];
//                    x_re[2][i] = d_re[0][3*i+2];
//                    x_im[2][i] = d_im[0][3*i+2];
//                    x_re[3][i] = d_re[1][4*i];
//                    x_im[3][i] = d_im[1][4*i];
//                    x_re[4][i] = d_re[1][4*i+1];
//                    x_im[4][i] = d_im[1][4*i+1];
//                    x_re[5][i] = d_re[1][4*i+2];
//                    x_im[5][i] = d_im[1][4*i+2];
//                    x_re[6][i] = d_re[1][4*i+3];
//                    x_im[6][i] = d_im[1][4*i+3];
                }
            }else{
                *M_layer_symb = M_symb/4;
                for(i=0; i<*M_layer_symb; i++)
                {
                    // FIXME
//                    x_re[0][i] = d_re[0][4*i];
//                    x_im[0][i] = d_im[0][4*i];
//                    x_re[1][i] = d_re[0][4*i+1];
//                    x_im[1][i] = d_im[0][4*i+1];
//                    x_re[2][i] = d_re[0][4*i+2];
//                    x_im[2][i] = d_im[0][4*i+2];
//                    x_re[3][i] = d_re[0][4*i+3];
//                    x_im[3][i] = d_im[0][4*i+3];
//                    x_re[4][i] = d_re[1][4*i];
//                    x_im[4][i] = d_im[1][4*i];
//                    x_re[5][i] = d_re[1][4*i+1];
//                    x_im[5][i] = d_im[1][4*i+1];
//                    x_re[6][i] = d_re[1][4*i+2];
//                    x_im[6][i] = d_im[1][4*i+2];
//                    x_re[7][i] = d_re[1][4*i+3];
//                    x_im[7][i] = d_im[1][4*i+3];
                }
            }
        }
    }
}

/*********************************************************************
    Name: layer_demapper

    Description: De-maps one or several layers into complex-valued
                 modulation symbols

    Document Reference: 3GPP TS 36.211 v10.1.0 section 6.3.3

    NOTES: Currently only supports single antenna or TX diversity
*********************************************************************/
void layer_demapper(float                          *x_re,
                    float                          *x_im,
                    uint32                          M_layer_symb,
                    uint32                          N_ant,
                    uint32                          N_codewords,
                    LIBLTE_PHY_PRE_CODER_TYPE_ENUM  type,
                    float                          *d_re,
                    float                          *d_im,
                    uint32                         *M_symb)
{
    float  *x_re_ptr[N_ant];
    float  *x_im_ptr[N_ant];
    uint32  i;
    uint32  p;

    // Index all arrays
    for(p=0; p<N_ant; p++)
    {
        x_re_ptr[p] = &x_re[p*M_layer_symb];
        x_im_ptr[p] = &x_im[p*M_layer_symb];
    }

    // 3GPP TS 36.211 v10.1.0 sections 6.3.3.1 and 6.3.3.3
    *M_symb = M_layer_symb*N_ant;
    if(N_ant                       == 4            &&
       x_re_ptr[2][M_layer_symb-1] == RX_NULL_SYMB &&
       x_im_ptr[2][M_layer_symb-1] == RX_NULL_SYMB &&
       x_re_ptr[3][M_layer_symb-1] == RX_NULL_SYMB &&
       x_im_ptr[3][M_layer_symb-1] == RX_NULL_SYMB)
    {
        *M_symb = *M_symb - 2;
    }
    for(i=0; i<M_layer_symb; i++)
    {
        for(p=0; p<N_ant; p++)
        {
            d_re[i*N_ant+p] = x_re_ptr[p][i];
            d_im[i*N_ant+p] = x_im_ptr[p][i];
        }
    }
}

/*********************************************************************
    Name: pre_coder

    Description: Generates a block of vectors to be mapped onto
                 resources on each antenna port

    Document Reference: 3GPP TS 36.211 v10.1.0 section 6.3.4

    NOTES: Currently only supports signle antenna or TX diversity
*********************************************************************/
void pre_coder(float                          *x_re,
               float                          *x_im,
               uint32                          M_layer_symb,
               uint32                          N_ant,
               LIBLTE_PHY_PRE_CODER_TYPE_ENUM  type,
               float                          *y_re,
               float                          *y_im,
               uint32                         *M_ap_symb)
{
//    float  one_over_sqrt_2 = 1/sqrt(2);
    uint32 i;

    if(N_ant == 1)
    {
        // 3GPP TS 36.211 v10.1.0 section 6.3.4.1
        *M_ap_symb = M_layer_symb;
        for(i=0; i<*M_ap_symb; i++)
        {
            y_re[i] = x_re[i];
            y_im[i] = x_im[i];
        }
    }else if(N_ant == 2){
        if(LIBLTE_PHY_PRE_CODER_TYPE_TX_DIVERSITY == type)
        {
            // 3GPP TS 36.211 v10.1.0 section 6.3.4.3
            *M_ap_symb = 2*M_layer_symb;
            for(i=0; i<M_layer_symb; i++)
            {
//                y_re[0][2*i+0] = +one_over_sqrt_2 * x_re[0][i];
//                y_im[0][2*i+0] = +one_over_sqrt_2 * x_im[0][i];
//                y_re[1][2*i+0] = -one_over_sqrt_2 * x_re[1][i];
//                y_im[1][2*i+0] = +one_over_sqrt_2 * x_im[1][i];
//                y_re[0][2*i+1] = +one_over_sqrt_2 * x_re[1][i];
//                y_im[0][2*i+1] = +one_over_sqrt_2 * x_im[1][i];
//                y_re[1][2*i+1] = +one_over_sqrt_2 * x_re[0][i];
//                y_im[1][2*i+1] = -one_over_sqrt_2 * x_im[0][i];
            }
        }else{
            // FIXME
        }
    }else{
        if(LIBLTE_PHY_PRE_CODER_TYPE_TX_DIVERSITY == type)
        {
            // 3GPP TS 36.211 v10.1.0 section 6.3.4.3
//            if(x_re[2][M_layer_symb-1] == NULL_SYMB &&
//               x_im[2][M_layer_symb-1] == NULL_SYMB &&
//               x_re[3][M_layer_symb-1] == NULL_SYMB &&
//               x_im[3][M_layer_symb-1] == NULL_SYMB)
//            {
//                *M_ap_symb = 4*M_layer_symb - 2;
//            }else{
//                *M_ap_symb = 4*M_layer_symb;
//            }
            for(i=0; i<M_layer_symb; i++)
            {
//                y_re[0][4*i+0] = +one_over_sqrt_2 * x_re[0][i];
//                y_im[0][4*i+0] = +one_over_sqrt_2 * x_im[0][i];
//                y_re[1][4*i+0] = 0;
//                y_im[1][4*i+0] = 0;
//                y_re[2][4*i+0] = -one_over_sqrt_2 * x_re[1][i];
//                y_im[2][4*i+0] = +one_over_sqrt_2 * x_im[1][i];
//                y_re[3][4*i+0] = 0;
//                y_im[3][4*i+0] = 0;
//                y_re[0][4*i+1] = +one_over_sqrt_2 * x_re[1][i];
//                y_im[0][4*i+1] = +one_over_sqrt_2 * x_im[1][i];
//                y_re[1][4*i+1] = 0;
//                y_im[1][4*i+1] = 0;
//                y_re[2][4*i+1] = +one_over_sqrt_2 * x_re[0][i];
//                y_im[2][4*i+1] = -one_over_sqrt_2 * x_im[0][i];
//                y_re[3][4*i+1] = 0;
//                y_im[3][4*i+1] = 0;
//                y_re[0][4*i+2] = 0;
//                y_im[0][4*i+2] = 0;
//                y_re[1][4*i+2] = +one_over_sqrt_2 * x_re[2][i];
//                y_im[1][4*i+2] = +one_over_sqrt_2 * x_im[2][i];
//                y_re[2][4*i+2] = 0;
//                y_im[2][4*i+2] = 0;
//                y_re[3][4*i+2] = -one_over_sqrt_2 * x_re[3][i];
//                y_im[3][4*i+2] = +one_over_sqrt_2 * x_im[3][i];
//                y_re[0][4*i+3] = 0;
//                y_im[0][4*i+3] = 0;
//                y_re[1][4*i+3] = +one_over_sqrt_2 * x_re[3][i];
//                y_im[1][4*i+3] = +one_over_sqrt_2 * x_im[3][i];
//                y_re[2][4*i+3] = 0;
//                y_im[2][4*i+3] = 0;
//                y_re[3][4*i+3] = +one_over_sqrt_2 * x_re[2][i];
//                y_im[3][4*i+3] = -one_over_sqrt_2 * x_im[2][i];
            }
        }else{
            // FIXME
        }
    }
}

/*********************************************************************
    Name: pre_decoder_and_matched_filter

    Description: Matched filters and unmaps a block of vectors from
                 resources on each antenna port

    Document Reference: 3GPP TS 36.211 v10.1.0 section 6.3.4

    NOTES: Currently only supports single antenna or TX diversity
*********************************************************************/
void pre_decoder_and_matched_filter(float                          *y_re,
                                    float                          *y_im,
                                    float                          *h_re,
                                    float                          *h_im,
                                    uint32                          h_len,
                                    uint32                          M_ap_symb,
                                    uint32                          N_ant,
                                    LIBLTE_PHY_PRE_CODER_TYPE_ENUM  type,
                                    float                          *x_re,
                                    float                          *x_im,
                                    uint32                         *M_layer_symb)
{
    float  *h_re_ptr[N_ant];
    float  *h_im_ptr[N_ant];
    float  *x_re_ptr[N_ant];
    float  *x_im_ptr[N_ant];
    float   h0_abs;
    float   h1_abs;
    float   h2_abs;
    float   h3_abs;
    float   h_norm;
    float   h_norm_0_2;
    float   h_norm_1_3;
    uint32  i;
    uint32  p;

    // Index all arrays
    for(p=0; p<N_ant; p++)
    {
        h_re_ptr[p] = &h_re[p*h_len];
        h_im_ptr[p] = &h_im[p*h_len];
        x_re_ptr[p] = &x_re[p*(M_ap_symb/N_ant)];
        x_im_ptr[p] = &x_im[p*(M_ap_symb/N_ant)];
    }

    if(N_ant == 1)
    {
        // 3GPP TS 36.211 v10.1.0 section 6.3.4.1
        *M_layer_symb = M_ap_symb;
        for(i=0; i<*M_layer_symb; i++)
        {
            x_re_ptr[0][i] = y_re[i]*h_re_ptr[0][i] + y_im[i]*h_im_ptr[0][i];
            x_im_ptr[0][i] = y_im[i]*h_re_ptr[0][i] - y_re[i]*h_im_ptr[0][i];
        }
    }else if(N_ant == 2){
        // 3GPP TS 36.211 v10.1.0 section 6.3.4.3
        *M_layer_symb = M_ap_symb/2;
        for(i=0; i<*M_layer_symb; i++)
        {
            h0_abs         = (h_re_ptr[0][i*2] * h_re_ptr[0][i*2] +
                              h_im_ptr[0][i*2] * h_im_ptr[0][i*2]);
            h1_abs         = (h_re_ptr[1][i*2] * h_re_ptr[1][i*2] +
                              h_im_ptr[1][i*2] * h_im_ptr[1][i*2]);
            h_norm         = sqrt(h0_abs*h0_abs + h1_abs*h1_abs);
            x_re_ptr[0][i] = (h_re_ptr[0][i*2] * y_re[i*2+0] +
                              h_im_ptr[0][i*2] * y_im[i*2+0] +
                              h_re_ptr[1][i*2] * y_re[i*2+1] +
                              h_im_ptr[1][i*2] * y_im[i*2+1]) / h_norm;
            x_im_ptr[0][i] = (h_re_ptr[0][i*2] * y_im[i*2+0] -
                              h_im_ptr[0][i*2] * y_re[i*2+0] -
                              h_re_ptr[1][i*2] * y_im[i*2+1] +
                              h_im_ptr[1][i*2] * y_re[i*2+1]) / h_norm;
            x_re_ptr[1][i] = (-h_re_ptr[1][i*2] * y_re[i*2+0] -
                              h_im_ptr[1][i*2] * y_im[i*2+0] +
                              h_re_ptr[0][i*2] * y_re[i*2+1] +
                              h_im_ptr[0][i*2] * y_im[i*2+1]) / h_norm;
            x_im_ptr[1][i] = (h_re_ptr[1][i*2] * y_im[i*2+0] -
                              h_im_ptr[1][i*2] * y_re[i*2+0] +
                              h_re_ptr[0][i*2] * y_im[i*2+1] -
                              h_im_ptr[0][i*2] * y_re[i*2+1]) / h_norm;
        }
    }else{ // N_ant == 4
        // 3GPP TS 36.211 v10.1.0 section 6.3.4.3
        *M_layer_symb = M_ap_symb/4;
        for(i=0; i<*M_layer_symb; i++)
        {
            h0_abs         = (h_re_ptr[0][i*4+0] * h_re_ptr[0][i*4+0] +
                              h_im_ptr[0][i*4+0] * h_im_ptr[0][i*4+0]);
            h1_abs         = (h_re_ptr[1][i*4+2] * h_re_ptr[1][i*4+2] +
                              h_im_ptr[1][i*4+2] * h_im_ptr[1][i*4+2]);
            h2_abs         = (h_re_ptr[2][i*4+0] * h_re_ptr[2][i*4+0] +
                              h_im_ptr[2][i*4+0] * h_im_ptr[2][i*4+0]);
            h3_abs         = (h_re_ptr[3][i*4+2] * h_re_ptr[3][i*4+2] +
                              h_im_ptr[3][i*4+2] * h_im_ptr[3][i*4+2]);
            h_norm_0_2     = sqrt(h0_abs*h0_abs + h2_abs*h2_abs);
            h_norm_1_3     = sqrt(h1_abs*h1_abs + h3_abs*h3_abs);
            x_re_ptr[0][i] = (h_re_ptr[0][i*4+0] * y_re[i*4+0] +
                              h_im_ptr[0][i*4+0] * y_im[i*4+0] +
                              h_re_ptr[2][i*4+0] * y_re[i*4+1] +
                              h_im_ptr[2][i*4+0] * y_im[i*4+1]) / h_norm_0_2;
            x_im_ptr[0][i] = (h_re_ptr[0][i*4+0] * y_im[i*4+0] -
                              h_im_ptr[0][i*4+0] * y_re[i*4+0] -
                              h_re_ptr[2][i*4+0] * y_im[i*4+1] +
                              h_im_ptr[2][i*4+0] * y_re[i*4+1]) / h_norm_0_2;
            x_re_ptr[1][i] = (-h_re_ptr[2][i*4+0] * y_re[i*4+0] -
                              h_im_ptr[2][i*4+0] * y_im[i*4+0] +
                              h_re_ptr[0][i*4+0] * y_re[i*4+1] +
                              h_im_ptr[0][i*4+0] * y_im[i*4+1]) / h_norm_0_2;
            x_im_ptr[1][i] = (-h_re_ptr[2][i*4+0] * y_im[i*4+0] +
                              h_im_ptr[2][i*4+0] * y_re[i*4+0] -
                              h_re_ptr[0][i*4+0] * y_re[i*4+1] +
                              h_im_ptr[0][i*4+0] * y_im[i*4+1]) / h_norm_0_2;
            x_re_ptr[2][i] = (h_re_ptr[1][i*4+2] * y_re[i*4+2] +
                              h_im_ptr[1][i*4+2] * y_im[i*4+2] +
                              h_re_ptr[3][i*4+2] * y_re[i*4+3] +
                              h_im_ptr[3][i*4+2] * y_im[i*4+3]) / h_norm_1_3;
            x_im_ptr[2][i] = (h_re_ptr[1][i*4+2] * y_im[i*4+2] -
                              h_im_ptr[1][i*4+2] * y_re[i*4+2] -
                              h_re_ptr[3][i*4+2] * y_im[i*4+3] +
                              h_im_ptr[3][i*4+2] * y_re[i*4+3]) / h_norm_1_3;
            x_re_ptr[3][i] = (-h_re_ptr[3][i*4+2] * y_re[i*4+2] -
                              h_im_ptr[3][i*4+2] * y_im[i*4+2] +
                              h_re_ptr[1][i*4+2] * y_re[i*4+3] +
                              h_im_ptr[1][i*4+2] * y_im[i*4+3]) / h_norm_1_3;
            x_im_ptr[3][i] = (-h_re_ptr[3][i*4+2] * y_im[i*4+2] +
                              h_im_ptr[3][i*4+2] * y_re[i*4+2] -
                              h_re_ptr[1][i*4+2] * y_re[i*4+3] +
                              h_im_ptr[1][i*4+2] * y_im[i*4+3]) / h_norm_1_3;
        }
        if((M_ap_symb % 4) != 0)
        {
            *M_layer_symb  = (M_ap_symb+2)/4;
            h0_abs         = (h_re_ptr[0][i*4+0] * h_re_ptr[0][i*4+0] +
                              h_im_ptr[0][i*4+0] * h_im_ptr[0][i*4+0]);
            h2_abs         = (h_re_ptr[2][i*4+0] * h_re_ptr[2][i*4+0] +
                              h_im_ptr[2][i*4+0] * h_im_ptr[2][i*4+0]);
            h_norm_0_2     = sqrt(h0_abs*h0_abs + h2_abs*h2_abs);
            x_re_ptr[0][i] = (h_re_ptr[0][i*4+0] * y_re[i*4+0] +
                              h_im_ptr[0][i*4+0] * y_im[i*4+0] +
                              h_re_ptr[2][i*4+0] * y_re[i*4+1] +
                              h_im_ptr[2][i*4+0] * y_im[i*4+1]) / h_norm_0_2;
            x_im_ptr[0][i] = (h_re_ptr[0][i*4+0] * y_im[i*4+0] -
                              h_im_ptr[0][i*4+0] * y_re[i*4+0] -
                              h_re_ptr[2][i*4+0] * y_im[i*4+1] +
                              h_im_ptr[2][i*4+0] * y_re[i*4+1]) / h_norm_0_2;
            x_re_ptr[1][i] = (-h_re_ptr[2][i*4+0] * y_re[i*4+0] -
                              h_im_ptr[2][i*4+0] * y_im[i*4+0] +
                              h_re_ptr[0][i*4+0] * y_re[i*4+1] +
                              h_im_ptr[0][i*4+0] * y_im[i*4+1]) / h_norm_0_2;
            x_im_ptr[1][i] = (-h_re_ptr[2][i*4+0] * y_im[i*4+0] +
                              h_im_ptr[2][i*4+0] * y_re[i*4+0] -
                              h_re_ptr[0][i*4+0] * y_re[i*4+1] +
                              h_im_ptr[0][i*4+0] * y_im[i*4+1]) / h_norm_0_2;
            x_re_ptr[2][i] = RX_NULL_SYMB;
            x_im_ptr[2][i] = RX_NULL_SYMB;
            x_re_ptr[3][i] = RX_NULL_SYMB;
            x_im_ptr[3][i] = RX_NULL_SYMB;
        }
    }
}

/*********************************************************************
    Name: generate_crs

    Description: Generates LTE cell specific reference signals

    Document Reference: 3GPP TS 36.211 v10.1.0 section 6.10.1.1
*********************************************************************/
void generate_crs(uint32  N_s,
                  uint32  L,
                  uint32  N_id_cell,
                  float  *crs_re,
                  float  *crs_im)
{
    float  one_over_sqrt_2 = 1/sqrt(2);
    uint32 N_cp = 1; // FIXME: Only supporting normal cp
    uint32 c_init;
    uint32 len = 2*LIBLTE_PHY_N_RB_DL_MAX;
    uint32 c[2*len];
    uint32 i;

    // Calculate c_init
    c_init = 1024 * (7 * (N_s+1) + L + 1) * (2 * N_id_cell + 1) + 2*N_id_cell + N_cp;

    // Generate the psuedo random sequence c
    generate_prs_c(c_init, 2*len, c);

    // Construct the reference signals
    for(i=0; i<len; i++)
    {
        crs_re[i] = one_over_sqrt_2*(1 - 2*(float)c[2*i]);
        crs_im[i] = one_over_sqrt_2*(1 - 2*(float)c[2*i+1]);
    }
}

/*********************************************************************
    Name: generate_pss

    Description: Generates an LTE primary synchronization signal

    Document Reference: 3GPP TS 36.211 v10.1.0 section 6.11.1.1
*********************************************************************/
void generate_pss(uint32  N_id_2,
                  float  *pss_re,
                  float  *pss_im)
{
    float  root_idx;
    uint32 i;

    if(N_id_2 == 0)
    {
        root_idx = 25;
    }else if(N_id_2 == 1){
        root_idx = 29;
    }else{
        root_idx = 34;
    }

    for(i=0; i<31; i++)
    {
        pss_re[i] = cosf(-M_PI*root_idx*i*(i+1)/63);
        pss_im[i] = sinf(-M_PI*root_idx*i*(i+1)/63);
    }
    for(i=31; i<62; i++)
    {
        pss_re[i] = cosf(-M_PI*root_idx*(i+1)*(i+2)/63);
        pss_im[i] = sinf(-M_PI*root_idx*(i+1)*(i+2)/63);
    }
}

/*********************************************************************
    Name: generate_sss

    Description: Generates LTE secondary synchronization signals

    Document Reference: 3GPP TS 36.211 v10.1.0 section 6.11.2.1
*********************************************************************/
void generate_sss(LIBLTE_PHY_STRUCT *phy_struct,
                  uint32             N_id_1,
                  uint32             N_id_2,
                  float             *sss_re_0,
                  float             *sss_im_0,
                  float             *sss_re_5,
                  float             *sss_im_5)
{
    uint32 i;
    uint32 q_prime;
    uint32 q;
    uint32 m_prime;
    uint32 m0;
    uint32 m1;

    // Generate m0 and m1
    q_prime = N_id_1/30;
    q       = (N_id_1 + (q_prime*(q_prime+1)/2))/30;
    m_prime = N_id_1 + (q*(q+1)/2);
    m0      = m_prime % 31;
    m1      = (m0 + (m_prime/31) + 1) % 31;

    // Generate s_tilda
    memset(phy_struct->sss_x_s_tilda, 0, sizeof(uint8)*31);
    phy_struct->sss_x_s_tilda[4] = 1;
    for(i=0; i<26; i++)
    {
        phy_struct->sss_x_s_tilda[i+5] = (phy_struct->sss_x_s_tilda[i+2] +
                                          phy_struct->sss_x_s_tilda[i]) % 2;
    }
    for(i=0; i<31; i++)
    {
        phy_struct->sss_s_tilda[i] = 1 - 2*phy_struct->sss_x_s_tilda[i];
    }

    // Generate c_tilda
    memset(phy_struct->sss_x_c_tilda, 0, sizeof(uint8)*31);
    phy_struct->sss_x_c_tilda[4] = 1;
    for(i=0; i<26; i++)
    {
        phy_struct->sss_x_c_tilda[i+5] = (phy_struct->sss_x_c_tilda[i+3] +
                                          phy_struct->sss_x_c_tilda[i]) % 2;
    }
    for(i=0; i<31; i++)
    {
        phy_struct->sss_c_tilda[i] = 1 - 2*phy_struct->sss_x_c_tilda[i];
    }

    // Generate z_tilda
    memset(phy_struct->sss_x_z_tilda, 0, sizeof(uint8)*31);
    phy_struct->sss_x_z_tilda[4] = 1;
    for(i=0; i<26; i++)
    {
        phy_struct->sss_x_z_tilda[i+5] = (phy_struct->sss_x_z_tilda[i+4] +
                                          phy_struct->sss_x_z_tilda[i+2] +
                                          phy_struct->sss_x_z_tilda[i+1] +
                                          phy_struct->sss_x_z_tilda[i]) % 2;
    }
    for(i=0; i<31; i++)
    {
        phy_struct->sss_z_tilda[i] = 1 - 2*phy_struct->sss_x_z_tilda[i];
    }

    // Generate s0_m0 and s1_m1
    for(i=0; i<31; i++)
    {
        phy_struct->sss_s0_m0[i] = phy_struct->sss_s_tilda[(i + m0) % 31];
        phy_struct->sss_s1_m1[i] = phy_struct->sss_s_tilda[(i + m1) % 31];
    }

    // Generate c0 and c1
    for(i=0; i<31; i++)
    {
        phy_struct->sss_c0[i] = phy_struct->sss_c_tilda[(i + N_id_2) % 31];
        phy_struct->sss_c1[i] = phy_struct->sss_c_tilda[(i + N_id_2 + 3) % 31];
    }

    // Generate z1_m0 and z1_m1
    for(i=0; i<31; i++)
    {
        phy_struct->sss_z1_m0[i] = phy_struct->sss_z_tilda[(i + (m0 % 8)) % 31];
        phy_struct->sss_z1_m1[i] = phy_struct->sss_z_tilda[(i + (m1 % 8)) % 31];
    }

    // Generate SSS
    for(i=0; i<31; i++)
    {
        sss_re_0[2*i]   = phy_struct->sss_s0_m0[i]*phy_struct->sss_c0[i];
        sss_im_0[2*i]   = 0;
        sss_re_0[2*i+1] = phy_struct->sss_s1_m1[i]*phy_struct->sss_c1[i]*phy_struct->sss_z1_m0[i];
        sss_im_0[2*i+1] = 0;

        sss_re_5[2*i]   = phy_struct->sss_s1_m1[i]*phy_struct->sss_c0[i];
        sss_im_5[2*i]   = 0;
        sss_re_5[2*i+1] = phy_struct->sss_s0_m0[i]*phy_struct->sss_c1[i]*phy_struct->sss_z1_m1[i];
        sss_im_5[2*i+1] = 0;
    }
}

/*********************************************************************
    Name: samples_to_symbols

    Description: Converts I/Q samples to subcarrier symbols

    Document Reference: 3GPP TS 36.211 v10.1.0 section 6.12
*********************************************************************/
void samples_to_symbols(LIBLTE_PHY_STRUCT *phy_struct,
                        float             *samps_re,
                        float             *samps_im,
                        uint32             slot_start_idx,
                        uint32             symbol_offset,
                        uint32             FFT_pad_size,
                        uint8              scale,
                        float             *symb_re,
                        float             *symb_im)
{
    fftw_plan     plan;
    fftw_complex *in;
    fftw_complex *out;
    uint32        CP_len;
    uint32        index;
    uint32        i;

    // Calculate index and CP length
    if((symbol_offset % 7) == 0)
    {
        CP_len = 160;
    }else{
        CP_len = 144;
    }
    index = slot_start_idx + (2048+144)*symbol_offset;
    if(symbol_offset > 0)
    {
        index += 16;
    }

    // FIXME
    in = (fftw_complex *)fftw_malloc(sizeof(fftw_complex)*2048*20);
    out = (fftw_complex *)fftw_malloc(sizeof(fftw_complex)*2048*20);
    plan = fftw_plan_dft_1d(2048, in, out, FFTW_FORWARD, FFTW_ESTIMATE);
    for(i=0; i<2048; i++)
    {
        in[i][0] = samps_re[index+CP_len-2+i];
        in[i][1] = samps_im[index+CP_len-2+i];
    }
    fftw_execute(plan);
    for(i=0; i<1024-FFT_pad_size; i++)
    {
        // Postive spectrum
        symb_re[i+(1024-FFT_pad_size)] = out[i+1][0];
        symb_im[i+(1024-FFT_pad_size)] = out[i+1][1];

        // Negative spectrum
        symb_re[(1024-FFT_pad_size)-i-1] = out[2048-i-1][0];
        symb_im[(1024-FFT_pad_size)-i-1] = out[2048-i-1][1];
    }
    fftw_destroy_plan(plan);
    fftw_free(in);
    fftw_free(out);

    if(scale == 1)
    {
        for(i=0; i<2*(1024-FFT_pad_size); i++)
        {
            symb_re[i] = cosf(atan2f(symb_im[i], symb_re[i]));
            symb_im[i] = sinf(atan2f(symb_im[i], symb_re[i]));
        }
    }
}

/*********************************************************************
    Name: modulation_mapper

    Description: Maps binary digits to complex-valued modulation
                 symbols

    Document Reference: 3GPP TS 36.211 v10.1.0 section 7.1

    NOTES: Currently only supports BPSK and QPSK
*********************************************************************/
void modulation_mapper(uint8                           *bits,
                       uint32                           N_bits,
                       LIBLTE_PHY_MODULATION_TYPE_ENUM  type,
                       float                           *d_re,
                       float                           *d_im,
                       uint32                          *M_symb)
{
    float  one_over_sqrt_2  = 1/sqrt(2);
    float  one_over_sqrt_10 = 1/sqrt(10);
    float  one_over_sqrt_42 = 1/sqrt(42);
    uint32 i;
    uint32 input;

    switch(type)
    {
    case LIBLTE_PHY_MODULATION_TYPE_BPSK:
        // 3GPP TS 36.211 v10.1.0 section 7.1.1
        for(i=0; i<N_bits; i++)
        {
            if(0 == bits[i])
            {
                d_re[i] = one_over_sqrt_2;
                d_im[i] = one_over_sqrt_2;
            }else{
                d_re[i] = -one_over_sqrt_2;
                d_im[i] = -one_over_sqrt_2;
            }
        }
        *M_symb = N_bits;
        break;
    case LIBLTE_PHY_MODULATION_TYPE_QPSK:
        // 3GPP TS 36.211 v10.1.0 section 7.1.2
        for(i=0; i<(N_bits/2); i++)
        {
            switch((bits[i*2] << 1) |
                   bits[i*2+1])
            {
            case 0:
                d_re[i] = +one_over_sqrt_2;
                d_im[i] = +one_over_sqrt_2;
                break;
            case 1:
                d_re[i] = +one_over_sqrt_2;
                d_im[i] = -one_over_sqrt_2;
                break;
            case 2:
                d_re[i] = -one_over_sqrt_2;
                d_im[i] = +one_over_sqrt_2;
                break;
            case 3:
                d_re[i] = -one_over_sqrt_2;
                d_im[i] = -one_over_sqrt_2;
                break;
            }
        }
        *M_symb = (N_bits/2);
        if((N_bits % 2) != 0)
        {
            *M_symb = (N_bits/2) + 1;
            // Add a trailing zero
            if(0 == bits[N_bits-1])
            {
                d_re[i] = +one_over_sqrt_2;
                d_im[i] = +one_over_sqrt_2;
            }else{
                d_re[i] = -one_over_sqrt_2;
                d_im[i] = +one_over_sqrt_2;
            }
        }
        break;
    case LIBLTE_PHY_MODULATION_TYPE_16QAM:
        // 3GPP TS 36.211 v10.1.0 section 7.1.3
        for(i=0; i<(N_bits/4); i++)
        {
            switch((bits[i*4+0] << 3) |
                   (bits[i*4+1] << 2) |
                   (bits[i*4+2] << 1) |
                   bits[i*4+3])
            {
            case 0:
                d_re[i] = +1*one_over_sqrt_10;
                d_im[i] = +1*one_over_sqrt_10;
                break;
            case 1:
                d_re[i] = +1*one_over_sqrt_10;
                d_im[i] = +3*one_over_sqrt_10;
                break;
            case 2:
                d_re[i] = +3*one_over_sqrt_10;
                d_im[i] = +1*one_over_sqrt_10;
                break;
            case 3:
                d_re[i] = +3*one_over_sqrt_10;
                d_im[i] = +3*one_over_sqrt_10;
                break;
            case 4:
                d_re[i] = +1*one_over_sqrt_10;
                d_im[i] = -1*one_over_sqrt_10;
                break;
            case 5:
                d_re[i] = +1*one_over_sqrt_10;
                d_im[i] = -3*one_over_sqrt_10;
                break;
            case 6:
                d_re[i] = +3*one_over_sqrt_10;
                d_im[i] = -1*one_over_sqrt_10;
                break;
            case 7:
                d_re[i] = +3*one_over_sqrt_10;
                d_im[i] = -3*one_over_sqrt_10;
                break;
            case 8:
                d_re[i] = -1*one_over_sqrt_10;
                d_im[i] = +1*one_over_sqrt_10;
                break;
            case 9:
                d_re[i] = -1*one_over_sqrt_10;
                d_im[i] = +3*one_over_sqrt_10;
                break;
            case 10:
                d_re[i] = -3*one_over_sqrt_10;
                d_im[i] = +1*one_over_sqrt_10;
                break;
            case 11:
                d_re[i] = -3*one_over_sqrt_10;
                d_im[i] = +3*one_over_sqrt_10;
                break;
            case 12:
                d_re[i] = -1*one_over_sqrt_10;
                d_im[i] = -1*one_over_sqrt_10;
                break;
            case 13:
                d_re[i] = -1*one_over_sqrt_10;
                d_im[i] = -3*one_over_sqrt_10;
                break;
            case 14:
                d_re[i] = -3*one_over_sqrt_10;
                d_im[i] = -1*one_over_sqrt_10;
                break;
            case 15:
                d_re[i] = -3*one_over_sqrt_10;
                d_im[i] = -3*one_over_sqrt_10;
                break;
            }
        }
        *M_symb = (N_bits/4);
        if((N_bits % 4) != 0)
        {
            *M_symb = (N_bits/4) + 1;
            if((N_bits % 4) == 1)
            {
                input = bits[N_bits-1] << 3;
            }else if((N_bits % 4) == 2){
                input = ((bits[N_bits-2] << 3) |
                        (bits[N_bits-1] << 2));
            }else if((N_bits % 4) == 3){
                input = ((bits[N_bits-3] << 3) |
                         (bits[N_bits-2] << 2) |
                         (bits[N_bits-1] << 1));
            }
            switch(input)
            {
            case 0:
                d_re[N_bits/4] = +1*one_over_sqrt_10;
                d_im[N_bits/4] = +1*one_over_sqrt_10;
                break;
            case 1:
                d_re[N_bits/4] = +1*one_over_sqrt_10;
                d_im[N_bits/4] = +3*one_over_sqrt_10;
                break;
            case 2:
                d_re[N_bits/4] = +3*one_over_sqrt_10;
                d_im[N_bits/4] = +1*one_over_sqrt_10;
                break;
            case 3:
                d_re[N_bits/4] = +3*one_over_sqrt_10;
                d_im[N_bits/4] = +3*one_over_sqrt_10;
                break;
            case 4:
                d_re[N_bits/4] = +1*one_over_sqrt_10;
                d_im[N_bits/4] = -1*one_over_sqrt_10;
                break;
            case 5:
                d_re[N_bits/4] = +1*one_over_sqrt_10;
                d_im[N_bits/4] = -3*one_over_sqrt_10;
                break;
            case 6:
                d_re[N_bits/4] = +3*one_over_sqrt_10;
                d_im[N_bits/4] = -1*one_over_sqrt_10;
                break;
            case 7:
                d_re[N_bits/4] = +3*one_over_sqrt_10;
                d_im[N_bits/4] = -3*one_over_sqrt_10;
                break;
            case 8:
                d_re[N_bits/4] = -1*one_over_sqrt_10;
                d_im[N_bits/4] = +1*one_over_sqrt_10;
                break;
            case 9:
                d_re[N_bits/4] = -1*one_over_sqrt_10;
                d_im[N_bits/4] = +3*one_over_sqrt_10;
                break;
            case 10:
                d_re[N_bits/4] = -3*one_over_sqrt_10;
                d_im[N_bits/4] = +1*one_over_sqrt_10;
                break;
            case 11:
                d_re[N_bits/4] = -3*one_over_sqrt_10;
                d_im[N_bits/4] = +3*one_over_sqrt_10;
                break;
            case 12:
                d_re[N_bits/4] = -1*one_over_sqrt_10;
                d_im[N_bits/4] = -1*one_over_sqrt_10;
                break;
            case 13:
                d_re[N_bits/4] = -1*one_over_sqrt_10;
                d_im[N_bits/4] = -3*one_over_sqrt_10;
                break;
            case 14:
                d_re[N_bits/4] = -3*one_over_sqrt_10;
                d_im[N_bits/4] = -1*one_over_sqrt_10;
                break;
            case 15:
                d_re[N_bits/4] = -3*one_over_sqrt_10;
                d_im[N_bits/4] = -3*one_over_sqrt_10;
                break;
            }
        }
        break;
    case LIBLTE_PHY_MODULATION_TYPE_64QAM:
        // 3GPP TS 36.211 v10.1.0 section 7.1.4
        for(i=0; i<(N_bits/6); i++)
        {
            switch((bits[i*6+0] << 5) |
                   (bits[i*6+1] << 4) |
                   (bits[i*6+2] << 3) |
                   (bits[i*6+3] << 2) |
                   (bits[i*6+4] << 1) |
                   bits[i*6+5])
            {
            case 0:
                d_re[i] = +3*one_over_sqrt_42;
                d_im[i] = +3*one_over_sqrt_42;
                break;
            case 1:
                d_re[i] = +3*one_over_sqrt_42;
                d_im[i] = +1*one_over_sqrt_42;
                break;
            case 2:
                d_re[i] = +1*one_over_sqrt_42;
                d_im[i] = +3*one_over_sqrt_42;
                break;
            case 3:
                d_re[i] = +1*one_over_sqrt_42;
                d_im[i] = +1*one_over_sqrt_42;
                break;
            case 4:
                d_re[i] = +3*one_over_sqrt_42;
                d_im[i] = +5*one_over_sqrt_42;
                break;
            case 5:
                d_re[i] = +3*one_over_sqrt_42;
                d_im[i] = +7*one_over_sqrt_42;
                break;
            case 6:
                d_re[i] = +1*one_over_sqrt_42;
                d_im[i] = +5*one_over_sqrt_42;
                break;
            case 7:
                d_re[i] = +1*one_over_sqrt_42;
                d_im[i] = +7*one_over_sqrt_42;
                break;
            case 8:
                d_re[i] = +5*one_over_sqrt_42;
                d_im[i] = +3*one_over_sqrt_42;
                break;
            case 9:
                d_re[i] = +5*one_over_sqrt_42;
                d_im[i] = +1*one_over_sqrt_42;
                break;
            case 10:
                d_re[i] = +7*one_over_sqrt_42;
                d_im[i] = +3*one_over_sqrt_42;
                break;
            case 11:
                d_re[i] = +7*one_over_sqrt_42;
                d_im[i] = +1*one_over_sqrt_42;
                break;
            case 12:
                d_re[i] = +5*one_over_sqrt_42;
                d_im[i] = +5*one_over_sqrt_42;
                break;
            case 13:
                d_re[i] = +5*one_over_sqrt_42;
                d_im[i] = +7*one_over_sqrt_42;
                break;
            case 14:
                d_re[i] = +7*one_over_sqrt_42;
                d_im[i] = +5*one_over_sqrt_42;
                break;
            case 15:
                d_re[i] = +7*one_over_sqrt_42;
                d_im[i] = +7*one_over_sqrt_42;
                break;
            case 16:
                d_re[i] = +3*one_over_sqrt_42;
                d_im[i] = -3*one_over_sqrt_42;
                break;
            case 17:
                d_re[i] = +3*one_over_sqrt_42;
                d_im[i] = -1*one_over_sqrt_42;
                break;
            case 18:
                d_re[i] = +1*one_over_sqrt_42;
                d_im[i] = -3*one_over_sqrt_42;
                break;
            case 19:
                d_re[i] = +1*one_over_sqrt_42;
                d_im[i] = -1*one_over_sqrt_42;
                break;
            case 20:
                d_re[i] = +3*one_over_sqrt_42;
                d_im[i] = -5*one_over_sqrt_42;
                break;
            case 21:
                d_re[i] = +3*one_over_sqrt_42;
                d_im[i] = -7*one_over_sqrt_42;
                break;
            case 22:
                d_re[i] = +1*one_over_sqrt_42;
                d_im[i] = -5*one_over_sqrt_42;
                break;
            case 23:
                d_re[i] = +1*one_over_sqrt_42;
                d_im[i] = -7*one_over_sqrt_42;
                break;
            case 24:
                d_re[i] = +5*one_over_sqrt_42;
                d_im[i] = -3*one_over_sqrt_42;
                break;
            case 25:
                d_re[i] = +5*one_over_sqrt_42;
                d_im[i] = -1*one_over_sqrt_42;
                break;
            case 26:
                d_re[i] = +7*one_over_sqrt_42;
                d_im[i] = -3*one_over_sqrt_42;
                break;
            case 27:
                d_re[i] = +7*one_over_sqrt_42;
                d_im[i] = -1*one_over_sqrt_42;
                break;
            case 28:
                d_re[i] = +5*one_over_sqrt_42;
                d_im[i] = -5*one_over_sqrt_42;
                break;
            case 29:
                d_re[i] = +5*one_over_sqrt_42;
                d_im[i] = -7*one_over_sqrt_42;
                break;
            case 30:
                d_re[i] = +7*one_over_sqrt_42;
                d_im[i] = -5*one_over_sqrt_42;
                break;
            case 31:
                d_re[i] = +7*one_over_sqrt_42;
                d_im[i] = -7*one_over_sqrt_42;
                break;
            case 32:
                d_re[i] = -3*one_over_sqrt_42;
                d_im[i] = +3*one_over_sqrt_42;
                break;
            case 33:
                d_re[i] = -3*one_over_sqrt_42;
                d_im[i] = +1*one_over_sqrt_42;
                break;
            case 34:
                d_re[i] = -1*one_over_sqrt_42;
                d_im[i] = +3*one_over_sqrt_42;
                break;
            case 35:
                d_re[i] = -1*one_over_sqrt_42;
                d_im[i] = +1*one_over_sqrt_42;
                break;
            case 36:
                d_re[i] = -3*one_over_sqrt_42;
                d_im[i] = +5*one_over_sqrt_42;
                break;
            case 37:
                d_re[i] = -3*one_over_sqrt_42;
                d_im[i] = +7*one_over_sqrt_42;
                break;
            case 38:
                d_re[i] = -1*one_over_sqrt_42;
                d_im[i] = +5*one_over_sqrt_42;
                break;
            case 39:
                d_re[i] = -1*one_over_sqrt_42;
                d_im[i] = +7*one_over_sqrt_42;
                break;
            case 40:
                d_re[i] = -5*one_over_sqrt_42;
                d_im[i] = +3*one_over_sqrt_42;
                break;
            case 41:
                d_re[i] = -5*one_over_sqrt_42;
                d_im[i] = +1*one_over_sqrt_42;
                break;
            case 42:
                d_re[i] = -7*one_over_sqrt_42;
                d_im[i] = +3*one_over_sqrt_42;
                break;
            case 43:
                d_re[i] = -7*one_over_sqrt_42;
                d_im[i] = +1*one_over_sqrt_42;
                break;
            case 44:
                d_re[i] = -5*one_over_sqrt_42;
                d_im[i] = +5*one_over_sqrt_42;
                break;
            case 45:
                d_re[i] = -5*one_over_sqrt_42;
                d_im[i] = +7*one_over_sqrt_42;
                break;
            case 46:
                d_re[i] = -7*one_over_sqrt_42;
                d_im[i] = +5*one_over_sqrt_42;
                break;
            case 47:
                d_re[i] = -7*one_over_sqrt_42;
                d_im[i] = +7*one_over_sqrt_42;
                break;
            case 48:
                d_re[i] = -3*one_over_sqrt_42;
                d_im[i] = -3*one_over_sqrt_42;
                break;
            case 49:
                d_re[i] = -3*one_over_sqrt_42;
                d_im[i] = -1*one_over_sqrt_42;
                break;
            case 50:
                d_re[i] = -1*one_over_sqrt_42;
                d_im[i] = -3*one_over_sqrt_42;
                break;
            case 51:
                d_re[i] = -1*one_over_sqrt_42;
                d_im[i] = -1*one_over_sqrt_42;
                break;
            case 52:
                d_re[i] = -3*one_over_sqrt_42;
                d_im[i] = -5*one_over_sqrt_42;
                break;
            case 53:
                d_re[i] = -3*one_over_sqrt_42;
                d_im[i] = -7*one_over_sqrt_42;
                break;
            case 54:
                d_re[i] = -1*one_over_sqrt_42;
                d_im[i] = -5*one_over_sqrt_42;
                break;
            case 55:
                d_re[i] = -1*one_over_sqrt_42;
                d_im[i] = -7*one_over_sqrt_42;
                break;
            case 56:
                d_re[i] = -5*one_over_sqrt_42;
                d_im[i] = -3*one_over_sqrt_42;
                break;
            case 57:
                d_re[i] = -5*one_over_sqrt_42;
                d_im[i] = -1*one_over_sqrt_42;
                break;
            case 58:
                d_re[i] = -7*one_over_sqrt_42;
                d_im[i] = -3*one_over_sqrt_42;
                break;
            case 59:
                d_re[i] = -7*one_over_sqrt_42;
                d_im[i] = -1*one_over_sqrt_42;
                break;
            case 60:
                d_re[i] = -5*one_over_sqrt_42;
                d_im[i] = -5*one_over_sqrt_42;
                break;
            case 61:
                d_re[i] = -5*one_over_sqrt_42;
                d_im[i] = -7*one_over_sqrt_42;
                break;
            case 62:
                d_re[i] = -7*one_over_sqrt_42;
                d_im[i] = -5*one_over_sqrt_42;
                break;
            case 63:
                d_re[i] = -7*one_over_sqrt_42;
                d_im[i] = -7*one_over_sqrt_42;
                break;
            }
        }
        *M_symb = (N_bits/6);
        if((N_bits % 6) != 0)
        {
            *M_symb = (N_bits/6) + 1;
            if((N_bits % 6) == 1)
            {
                input = bits[N_bits-1] << 5;
            }else if((N_bits % 6) == 2){
                input = ((bits[N_bits-2] << 5) |
                         (bits[N_bits-1] << 4));
            }else if((N_bits % 6) == 3){
                input = ((bits[N_bits-3] << 5) |
                         (bits[N_bits-2] << 4) |
                         (bits[N_bits-1] << 3));
            }else if((N_bits % 6) == 4){
                input = ((bits[N_bits-4] << 5) |
                         (bits[N_bits-3] << 4) |
                         (bits[N_bits-2] << 3) |
                         (bits[N_bits-1] << 2));
            }else if((N_bits % 6) == 5){
                input = ((bits[N_bits-5] << 5) |
                         (bits[N_bits-4] << 4) |
                         (bits[N_bits-3] << 3) |
                         (bits[N_bits-2] << 2) |
                         (bits[N_bits-1] << 1));
            }
            switch(input)
            {
            case 0:
                d_re[N_bits/6] = +3*one_over_sqrt_42;
                d_im[N_bits/6] = +3*one_over_sqrt_42;
                break;
            case 1:
                d_re[N_bits/6] = +3*one_over_sqrt_42;
                d_im[N_bits/6] = +1*one_over_sqrt_42;
                break;
            case 2:
                d_re[N_bits/6] = +1*one_over_sqrt_42;
                d_im[N_bits/6] = +3*one_over_sqrt_42;
                break;
            case 3:
                d_re[N_bits/6] = +1*one_over_sqrt_42;
                d_im[N_bits/6] = +1*one_over_sqrt_42;
                break;
            case 4:
                d_re[N_bits/6] = +3*one_over_sqrt_42;
                d_im[N_bits/6] = +5*one_over_sqrt_42;
                break;
            case 5:
                d_re[N_bits/6] = +3*one_over_sqrt_42;
                d_im[N_bits/6] = +7*one_over_sqrt_42;
                break;
            case 6:
                d_re[N_bits/6] = +1*one_over_sqrt_42;
                d_im[N_bits/6] = +5*one_over_sqrt_42;
                break;
            case 7:
                d_re[N_bits/6] = +1*one_over_sqrt_42;
                d_im[N_bits/6] = +7*one_over_sqrt_42;
                break;
            case 8:
                d_re[N_bits/6] = +5*one_over_sqrt_42;
                d_im[N_bits/6] = +3*one_over_sqrt_42;
                break;
            case 9:
                d_re[N_bits/6] = +5*one_over_sqrt_42;
                d_im[N_bits/6] = +1*one_over_sqrt_42;
                break;
            case 10:
                d_re[N_bits/6] = +7*one_over_sqrt_42;
                d_im[N_bits/6] = +3*one_over_sqrt_42;
                break;
            case 11:
                d_re[N_bits/6] = +7*one_over_sqrt_42;
                d_im[N_bits/6] = +1*one_over_sqrt_42;
                break;
            case 12:
                d_re[N_bits/6] = +5*one_over_sqrt_42;
                d_im[N_bits/6] = +5*one_over_sqrt_42;
                break;
            case 13:
                d_re[N_bits/6] = +5*one_over_sqrt_42;
                d_im[N_bits/6] = +7*one_over_sqrt_42;
                break;
            case 14:
                d_re[N_bits/6] = +7*one_over_sqrt_42;
                d_im[N_bits/6] = +5*one_over_sqrt_42;
                break;
            case 15:
                d_re[N_bits/6] = +7*one_over_sqrt_42;
                d_im[N_bits/6] = +7*one_over_sqrt_42;
                break;
            case 16:
                d_re[N_bits/6] = +3*one_over_sqrt_42;
                d_im[N_bits/6] = -3*one_over_sqrt_42;
                break;
            case 17:
                d_re[N_bits/6] = +3*one_over_sqrt_42;
                d_im[N_bits/6] = -1*one_over_sqrt_42;
                break;
            case 18:
                d_re[N_bits/6] = +1*one_over_sqrt_42;
                d_im[N_bits/6] = -3*one_over_sqrt_42;
                break;
            case 19:
                d_re[N_bits/6] = +1*one_over_sqrt_42;
                d_im[N_bits/6] = -1*one_over_sqrt_42;
                break;
            case 20:
                d_re[N_bits/6] = +3*one_over_sqrt_42;
                d_im[N_bits/6] = -5*one_over_sqrt_42;
                break;
            case 21:
                d_re[N_bits/6] = +3*one_over_sqrt_42;
                d_im[N_bits/6] = -7*one_over_sqrt_42;
                break;
            case 22:
                d_re[N_bits/6] = +1*one_over_sqrt_42;
                d_im[N_bits/6] = -5*one_over_sqrt_42;
                break;
            case 23:
                d_re[N_bits/6] = +1*one_over_sqrt_42;
                d_im[N_bits/6] = -7*one_over_sqrt_42;
                break;
            case 24:
                d_re[N_bits/6] = +5*one_over_sqrt_42;
                d_im[N_bits/6] = -3*one_over_sqrt_42;
                break;
            case 25:
                d_re[N_bits/6] = +5*one_over_sqrt_42;
                d_im[N_bits/6] = -1*one_over_sqrt_42;
                break;
            case 26:
                d_re[N_bits/6] = +7*one_over_sqrt_42;
                d_im[N_bits/6] = -3*one_over_sqrt_42;
                break;
            case 27:
                d_re[N_bits/6] = +7*one_over_sqrt_42;
                d_im[N_bits/6] = -1*one_over_sqrt_42;
                break;
            case 28:
                d_re[N_bits/6] = +5*one_over_sqrt_42;
                d_im[N_bits/6] = -5*one_over_sqrt_42;
                break;
            case 29:
                d_re[N_bits/6] = +5*one_over_sqrt_42;
                d_im[N_bits/6] = -7*one_over_sqrt_42;
                break;
            case 30:
                d_re[N_bits/6] = +7*one_over_sqrt_42;
                d_im[N_bits/6] = -5*one_over_sqrt_42;
                break;
            case 31:
                d_re[N_bits/6] = +7*one_over_sqrt_42;
                d_im[N_bits/6] = -7*one_over_sqrt_42;
                break;
            case 32:
                d_re[N_bits/6] = -3*one_over_sqrt_42;
                d_im[N_bits/6] = +3*one_over_sqrt_42;
                break;
            case 33:
                d_re[N_bits/6] = -3*one_over_sqrt_42;
                d_im[N_bits/6] = +1*one_over_sqrt_42;
                break;
            case 34:
                d_re[N_bits/6] = -1*one_over_sqrt_42;
                d_im[N_bits/6] = +3*one_over_sqrt_42;
                break;
            case 35:
                d_re[N_bits/6] = -1*one_over_sqrt_42;
                d_im[N_bits/6] = +1*one_over_sqrt_42;
                break;
            case 36:
                d_re[N_bits/6] = -3*one_over_sqrt_42;
                d_im[N_bits/6] = +5*one_over_sqrt_42;
                break;
            case 37:
                d_re[N_bits/6] = -3*one_over_sqrt_42;
                d_im[N_bits/6] = +7*one_over_sqrt_42;
                break;
            case 38:
                d_re[N_bits/6] = -1*one_over_sqrt_42;
                d_im[N_bits/6] = +5*one_over_sqrt_42;
                break;
            case 39:
                d_re[N_bits/6] = -1*one_over_sqrt_42;
                d_im[N_bits/6] = +7*one_over_sqrt_42;
                break;
            case 40:
                d_re[N_bits/6] = -5*one_over_sqrt_42;
                d_im[N_bits/6] = +3*one_over_sqrt_42;
                break;
            case 41:
                d_re[N_bits/6] = -5*one_over_sqrt_42;
                d_im[N_bits/6] = +1*one_over_sqrt_42;
                break;
            case 42:
                d_re[N_bits/6] = -7*one_over_sqrt_42;
                d_im[N_bits/6] = +3*one_over_sqrt_42;
                break;
            case 43:
                d_re[N_bits/6] = -7*one_over_sqrt_42;
                d_im[N_bits/6] = +1*one_over_sqrt_42;
                break;
            case 44:
                d_re[N_bits/6] = -5*one_over_sqrt_42;
                d_im[N_bits/6] = +5*one_over_sqrt_42;
                break;
            case 45:
                d_re[N_bits/6] = -5*one_over_sqrt_42;
                d_im[N_bits/6] = +7*one_over_sqrt_42;
                break;
            case 46:
                d_re[N_bits/6] = -7*one_over_sqrt_42;
                d_im[N_bits/6] = +5*one_over_sqrt_42;
                break;
            case 47:
                d_re[N_bits/6] = -7*one_over_sqrt_42;
                d_im[N_bits/6] = +7*one_over_sqrt_42;
                break;
            case 48:
                d_re[N_bits/6] = -3*one_over_sqrt_42;
                d_im[N_bits/6] = -3*one_over_sqrt_42;
                break;
            case 49:
                d_re[N_bits/6] = -3*one_over_sqrt_42;
                d_im[N_bits/6] = -1*one_over_sqrt_42;
                break;
            case 50:
                d_re[N_bits/6] = -1*one_over_sqrt_42;
                d_im[N_bits/6] = -3*one_over_sqrt_42;
                break;
            case 51:
                d_re[N_bits/6] = -1*one_over_sqrt_42;
                d_im[N_bits/6] = -1*one_over_sqrt_42;
                break;
            case 52:
                d_re[N_bits/6] = -3*one_over_sqrt_42;
                d_im[N_bits/6] = -5*one_over_sqrt_42;
                break;
            case 53:
                d_re[N_bits/6] = -3*one_over_sqrt_42;
                d_im[N_bits/6] = -7*one_over_sqrt_42;
                break;
            case 54:
                d_re[N_bits/6] = -1*one_over_sqrt_42;
                d_im[N_bits/6] = -5*one_over_sqrt_42;
                break;
            case 55:
                d_re[N_bits/6] = -1*one_over_sqrt_42;
                d_im[N_bits/6] = -7*one_over_sqrt_42;
                break;
            case 56:
                d_re[N_bits/6] = -5*one_over_sqrt_42;
                d_im[N_bits/6] = -3*one_over_sqrt_42;
                break;
            case 57:
                d_re[N_bits/6] = -5*one_over_sqrt_42;
                d_im[N_bits/6] = -1*one_over_sqrt_42;
                break;
            case 58:
                d_re[N_bits/6] = -7*one_over_sqrt_42;
                d_im[N_bits/6] = -3*one_over_sqrt_42;
                break;
            case 59:
                d_re[N_bits/6] = -7*one_over_sqrt_42;
                d_im[N_bits/6] = -1*one_over_sqrt_42;
                break;
            case 60:
                d_re[N_bits/6] = -5*one_over_sqrt_42;
                d_im[N_bits/6] = -5*one_over_sqrt_42;
                break;
            case 61:
                d_re[N_bits/6] = -5*one_over_sqrt_42;
                d_im[N_bits/6] = -7*one_over_sqrt_42;
                break;
            case 62:
                d_re[N_bits/6] = -7*one_over_sqrt_42;
                d_im[N_bits/6] = -5*one_over_sqrt_42;
                break;
            case 63:
                d_re[N_bits/6] = -7*one_over_sqrt_42;
                d_im[N_bits/6] = -7*one_over_sqrt_42;
                break;
            }
        }
        break;
    }
}

/*********************************************************************
    Name: modulation_demapper

    Description: Maps complex-valued modulation symbols to binary
                 digits

    Document Reference: 3GPP TS 36.211 v10.1.0 section 7.1

    NOTES: Currently only supports BPSK and QPSK
*********************************************************************/
void modulation_demapper(float                           *d_re,
                         float                           *d_im,
                         uint32                           M_symb,
                         LIBLTE_PHY_MODULATION_TYPE_ENUM  type,
                         int8                            *bits,
                         uint32                          *N_bits)
{
    float  ang;
    float  sd;
    float  act_d_re;
    float  act_d_im;
    float  one_over_sqrt_2 = 1/sqrt(2);
    uint32 i;

    if(LIBLTE_PHY_MODULATION_TYPE_BPSK == type)
    {
        // 3GPP TS 36.211 v10.1.0 section 7.1.1
        *N_bits = M_symb;
        for(i=0; i<M_symb; i++)
        {
            ang = atan2f(d_im[i], d_re[i]);
            if((ang > -M_PI/4) && (ang < 3*M_PI/4))
            {
                act_d_re = +one_over_sqrt_2;
                act_d_im = +one_over_sqrt_2;
                sd       = get_soft_decision(d_re[i], d_im[i], act_d_re, act_d_im, 1);
                bits[i]  = +(int8)(127*sd);
            }else{
                act_d_re = -one_over_sqrt_2;
                act_d_im = -one_over_sqrt_2;
                sd       = get_soft_decision(d_re[i], d_im[i], act_d_re, act_d_im, 1);
                bits[i]  = -(int8)(127*sd);
            }
        }
    }else{ // LIBLTE_PHY_MODULATION_TYPE_QPSK == type
        // 3GPP TS 36.211 v10.1.0 section 7.1.2
        *N_bits = M_symb*2;
        for(i=0; i<M_symb; i++)
        {
            ang = atan2f(d_im[i], d_re[i]);
            if((ang >= 0) && (ang < M_PI/2))
            {
                act_d_re    = +one_over_sqrt_2;
                act_d_im    = +one_over_sqrt_2;
                sd          = get_soft_decision(d_re[i], d_im[i], act_d_re, act_d_im, 1);
                bits[i*2+0] = +(int8)(127*sd);
                bits[i*2+1] = +(int8)(127*sd);
            }else if((ang >= -M_PI/2) && (ang < 0)){
                act_d_re    = +one_over_sqrt_2;
                act_d_im    = -one_over_sqrt_2;
                sd          = get_soft_decision(d_re[i], d_im[i], act_d_re, act_d_im, 1);
                bits[i*2+0] = +(int8)(127*sd);
                bits[i*2+1] = -(int8)(127*sd);
            }else if((ang >= M_PI/2) && (ang < M_PI)){
                act_d_re    = -one_over_sqrt_2;
                act_d_im    = +one_over_sqrt_2;
                sd          = get_soft_decision(d_re[i], d_im[i], act_d_re, act_d_im, 1);
                bits[i*2+0] = -(int8)(127*sd);
                bits[i*2+1] = +(int8)(127*sd);
            }else{
                act_d_re    = -one_over_sqrt_2;
                act_d_im    = -one_over_sqrt_2;
                sd          = get_soft_decision(d_re[i], d_im[i], act_d_re, act_d_im, 1);
                bits[i*2+0] = -(int8)(127*sd);
                bits[i*2+1] = -(int8)(127*sd);
            }
        }
    }
}

/*********************************************************************
    Name: generate_prs_c

    Description: Generates the psuedo random sequence c

    Document Reference: 3GPP TS 36.211 v10.1.0 section 7.2
*********************************************************************/
void generate_prs_c(uint32  c_init,
                    uint32  len,
                    uint32 *c)
{
    uint32 i;
    uint32 j;
    uint8  x1[31];
    uint8  x2[31];
    uint8  new_bit1;
    uint8  new_bit2;

    // Initialize the m-sequences
    for(i=0; i<31; i++)
    {
        x1[i] = 0;
        x2[i] = (c_init & (1<<i))>>i;
    }
    x1[0] = 1;

    // Advance m-sequences
    for(i=0; i<(1600-31); i++)
    {
        new_bit1 = x1[3] ^ x1[0];
        new_bit2 = x2[3] ^ x2[2] ^ x2[1] ^ x2[0];

        for(j=0; j<30; j++)
        {
            x1[j] = x1[j+1];
            x2[j] = x2[j+1];
        }
        x1[30] = new_bit1;
        x2[30] = new_bit2;
    }

    // Generate c
    for(i=0; i<len; i++)
    {
        new_bit1 = x1[3] ^ x1[0];
        new_bit2 = x2[3] ^ x2[2] ^ x2[1] ^ x2[0];

        for(j=0; j<30; j++)
        {
            x1[j] = x1[j+1];
            x2[j] = x2[j+1];
        }
        x1[30] = new_bit1;
        x2[30] = new_bit2;

        c[i] = new_bit1 ^ new_bit2;
    }
}

/*********************************************************************
    Name: calc_crc

    Description: Calculates one of the LTE CRCs

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.1
*********************************************************************/
void calc_crc(uint8  *a_bits,
              uint32  N_a_bits,
              uint32  crc,
              uint8  *p_bits,
              uint32  N_p_bits)
{
    uint32 i;
    uint32 crc_rem   = 0;
    uint32 crc_check = (1 << N_p_bits);
    uint8  tmp_array[N_a_bits + N_p_bits];

    // Initialize tmp_array
    memset(tmp_array, 0, N_a_bits + N_p_bits);
    memcpy(tmp_array, a_bits, N_a_bits);

    for(i=0; i<N_a_bits + N_p_bits; i++)
    {
        crc_rem <<= 1;
        crc_rem  |= tmp_array[i];

        if(crc_rem & crc_check)
        {
            crc_rem ^= crc;
        }
    }

    for(i=0; i<N_p_bits; i++)
    {
        p_bits[i] = (crc_rem >> (N_p_bits-1-i)) & 1;
    }
}

/*********************************************************************
    Name: code_block_segmentation

    Description: Performs code block segmentation for turbo coded
                 channels

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.2
*********************************************************************/
void code_block_segmentation(uint8  *b_bits,
                             uint32  N_b_bits,
                             uint32 *N_codeblocks,
                             uint32 *N_filler_bits,
                             uint8  *c_bits,
                             uint32  N_c_bits_max,
                             uint32 *N_c_bits)
{
    uint32 Z = 6144;
    uint32 L;
    uint32 B;
    uint32 C;
    uint32 F;
    uint32 B_prime;
    uint32 K_plus  = 0;
    uint32 K_minus = 0;
    uint32 K_delta;
    uint32 K_r;
    uint32 C_plus;
    uint32 C_minus;
    uint32 k;
    uint32 s;
    uint32 r;
    int32  i;
    uint8  p_cb_bits[24];

    // Determine L, C, B', K+, C+, K-, and C-
    if(N_b_bits <= Z)
    {
        L       = 0;
        C       = 1;
        B_prime = N_b_bits;
        for(i=0; i<TURBO_INT_K_TABLE_SIZE; i++)
        {
            if(C*TURBO_INT_K_TABLE[i] >= B_prime)
            {
                K_plus = TURBO_INT_K_TABLE[i];
                break;
            }
        }
        K_minus = 0;
        C_plus  = 1;
        C_minus = 0;
    }else{
        B       = N_b_bits;
        L       = 24;
        C       = (uint32)ceilf((float)B/(float)(Z-L));
        B_prime = B + C*L;
        for(i=0; i<TURBO_INT_K_TABLE_SIZE; i++)
        {
            if(C*TURBO_INT_K_TABLE[i] >= B_prime)
            {
                K_plus = TURBO_INT_K_TABLE[i];
                break;
            }
        }
        for(i=TURBO_INT_K_TABLE_SIZE-1; i>=0; i--)
        {
            if(TURBO_INT_K_TABLE[i] < K_plus)
            {
                K_minus = TURBO_INT_K_TABLE[i];
                break;
            }
        }
        K_delta = K_plus - K_minus;
        C_minus = (C*K_plus - B_prime)/K_delta;
        C_plus  = C - C_minus;
    }

    // Determine the number of filler bits and add them
    *N_codeblocks  = C;
    F              = C_plus*K_plus + C_minus*K_minus - B_prime;
    *N_filler_bits = F;
    for(i=0; i<(int32)F; i++)
    {
        c_bits[i] = TX_NULL_SYMB;
    }

    // Add the input bits
    k = F;
    s = 0;
    for(r=0; r<C; r++)
    {
        // Determine the K for this code block
        if(r < C_minus)
        {
            K_r = K_minus;
        }else{
            K_r = K_plus;
        }
        N_c_bits[r] = K_r;

        // Add the input bits
        while(k < (K_r - L))
        {
            c_bits[r*N_c_bits_max+k] = b_bits[s++];
            k++;
        }

        // Add CRC if more than 1 code block is needed
        if(C > 1)
        {
            calc_crc(&c_bits[r*N_c_bits_max], N_c_bits[r], CRC24B, p_cb_bits, L);
            N_c_bits[r] += L;
            while(k < K_r)
            {
                c_bits[r*N_c_bits_max+k] = p_cb_bits[k+L-K_r];
                k++;
            }
        }
        k = 0;
    }
}

/*********************************************************************
    Name: code_block_desegmentation

    Description: Performs code block desegmentation for turbo coded
                 channels

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.2
*********************************************************************/
void code_block_desegmentation(uint8  *c_bits,
                               uint32 *N_c_bits,
                               uint32  N_c_bits_max,
                               uint32  tbs,
                               uint8  *b_bits,
                               uint32  N_b_bits)
{
    uint32  Z = 6144;
    uint32  L;
    uint32  B;
    uint32  C;
    uint32  F;
    uint32  B_prime;
    uint32  K_plus  = 0;
    uint32  K_minus = 0;
    uint32  K_delta;
    uint32  K_r;
    uint32  C_plus;
    uint32  C_minus;
    uint32  k;
    uint32  s;
    uint32  r;
    uint32  ber;
    int32   i;
    uint8  *p_cb_bits;
    uint8   calc_p_cb_bits[24];

    // Determine L, C, B', K+, C+, K-, and C-
    if(tbs+24 <= Z)
    {
        L       = 0;
        C       = 1;
        B_prime = tbs+24;
        for(i=0; i<TURBO_INT_K_TABLE_SIZE; i++)
        {
            if(C*TURBO_INT_K_TABLE[i] >= B_prime)
            {
                K_plus = TURBO_INT_K_TABLE[i];
                break;
            }
        }
        K_minus = 0;
        C_plus  = 1;
        C_minus = 0;
    }else{
        B       = tbs+24;
        L       = 24;
        C       = (uint32)ceilf((float)B/(float)(Z-L));
        B_prime = B + C*L;
        for(i=0; i<TURBO_INT_K_TABLE_SIZE; i++)
        {
            if(C*TURBO_INT_K_TABLE[i] >= B_prime)
            {
                K_plus = TURBO_INT_K_TABLE[i];
                break;
            }
        }
        for(i=TURBO_INT_K_TABLE_SIZE-1; i>=0; i--)
        {
            if(TURBO_INT_K_TABLE[i] < K_plus)
            {
                K_minus = TURBO_INT_K_TABLE[i];
                break;
            }
        }
        K_delta = K_plus - K_minus;
        C_minus = (C*K_plus - B_prime)/K_delta;
        C_plus  = C - C_minus;
    }

    // Determine the number of filler bits
    F = C_plus*K_plus + C_minus*K_minus - B_prime;

    // Determine the output bits
    k = F;
    s = 0;
    for(r=0; r<C; r++)
    {
        // Determine the K for this code block
        if(r < C_minus)
        {
            K_r = K_minus;
        }else{
            K_r = K_plus;
        }

        // Check CRC if more than 1 code block is present
        if(C > 1)
        {
            calc_crc(&c_bits[r*N_c_bits_max], N_c_bits[r]-L, CRC24B, calc_p_cb_bits, L);
            p_cb_bits = &c_bits[r*N_c_bits_max+N_c_bits[r]-L];
            ber       = 0;
            for(i=0; i<(int32)L; i++)
            {
                ber += p_cb_bits[i] ^ calc_p_cb_bits[i];
            }
            if(ber == 0)
            {
                printf("CB CRC CORRECT\n");
            }else{
                printf("CB CRC INCORRECT\n");
            }
        }

        // Create the output bits
        while(k < (K_r - L))
        {
            b_bits[s++] = c_bits[r*N_c_bits_max+k];
            k++;
        }
        k = 0;
    }
}

/*********************************************************************
    Name: conv_encode

    Description: Convolutionally encodes a bit array using the
                 provided parameters

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.3.1
*********************************************************************/
void conv_encode(LIBLTE_PHY_STRUCT *phy_struct,
                 uint8             *c_bits,
                 uint32             N_c_bits,
                 uint32             constraint_len,
                 uint32             rate,
                 uint32            *g,
                 bool               tail_bit,
                 uint8             *d_bits,
                 uint32            *N_d_bits)
{
    uint32 i;
    uint32 j;
    uint32 k;
    uint8  s_reg[constraint_len];
    uint8  g_array[3][constraint_len];

    // Initialize the shift register
    if(tail_bit)
    {
        for(i=0; i<constraint_len; i++)
        {
            s_reg[i] = c_bits[N_c_bits-i-1];
        }
    }else{
        for(i=0; i<constraint_len; i++)
        {
            s_reg[i] = 0;
        }
    }

    // Convert g from octal to binary array
    for(i=0; i<rate; i++)
    {
        for(j=0; j<constraint_len; j++)
        {
            g_array[i][j] = (g[i] >> (constraint_len-j-1)) & 1;
        }
    }

    // Convolutionally encode input
    for(i=0; i<N_c_bits; i++)
    {
        // Add next bit to shift register
        for(j=constraint_len-1; j>0; j--)
        {
            s_reg[j] = s_reg[j-1];
        }
        s_reg[0] = c_bits[i];

        // Determine the output bits
        for(j=0; j<rate; j++)
        {
            d_bits[i*rate + j] = 0;

            for(k=0; k<constraint_len; k++)
            {
                d_bits[i*rate + j] += s_reg[k]*g_array[j][k];
            }
            d_bits[i*rate + j] %= 2;
        }
    }
}

/*********************************************************************
    Name: viterbi_decode

    Description: Viterbi decodes a convolutionally coded input bit
                 array using the provided parameters

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.3.1
*********************************************************************/
void viterbi_decode(LIBLTE_PHY_STRUCT *phy_struct,
                    float             *d_bits,
                    uint32             N_d_bits,
                    uint32             constraint_len,
                    uint32             rate,
                    uint32            *g,
                    uint8             *c_bits,
                    uint32            *N_c_bits)
{
    float  init_min;
    float  tmp1;
    float  tmp2;
    int32  i;
    uint32 j;
    uint32 k;
    uint32 o;
    uint32 N_states = 1<<(constraint_len-1);
    uint32 idx;
    uint32 tb_state_len;
    uint8  in_path;
    uint8  prev_state;
    uint8  in_bit;
    uint8  prev_state_0;
    uint8  prev_state_1;
    uint8  s_reg[constraint_len];
    uint8  g_array[3][constraint_len];

    // Convert g to binary
    for(i=0; i<(int32)rate; i++)
    {
        for(j=0; j<constraint_len; j++)
        {
            g_array[i][j] = (g[i] >> (constraint_len-j-1)) & 1;
        }
    }

    // Precalculate state transition outputs
    for(i=0; i<(int32)N_states; i++)
    {
        // Determine the input path
        if(i < (N_states/2))
        {
            in_path = 0;
        }else{
            in_path = 1;
        }

        // Determine the outputs based on the previous state and input path
        for(j=0; j<2; j++)
        {
            prev_state = ((i << 1) + j) % N_states;
            for(k=0; k<constraint_len; k++)
            {
                s_reg[k] = (prev_state >> (constraint_len-k-1)) & 1;
            }
            s_reg[0]   = in_path;
            for(k=0; k<rate; k++)
            {
                phy_struct->vd_st_output[i][j][k] = 0;
                for(o=0; o<constraint_len; o++)
                {
                    phy_struct->vd_st_output[i][j][k] += s_reg[o]*g_array[k][o];
                }
                phy_struct->vd_st_output[i][j][k] %= 2;
            }
        }
    }

    // Calculate branch and path metrics
    for(i=0; i<(int32)N_states; i++)
    {
        for(j=0; j<(N_d_bits/rate)+10; j++)
        {
            phy_struct->vd_path_metric[i][j] = 0;
        }
    }
    for(i=0; i<(int32)(N_d_bits/rate); i++)
    {
        for(j=0; j<N_states; j++)
        {
            phy_struct->vd_br_metric[j][0] = 0;
            phy_struct->vd_br_metric[j][1] = 0;
            phy_struct->vd_p_metric[j][0]  = 0;
            phy_struct->vd_p_metric[j][1]  = 0;
            phy_struct->vd_w_metric[j][0]  = 0;
            phy_struct->vd_w_metric[j][1]  = 0;

            // Calculate the accumulated branch metrics for each state
            for(k=0; k<2; k++)
            {
                prev_state                    = ((j<<1)+k) % N_states;
                phy_struct->vd_p_metric[j][k] = phy_struct->vd_path_metric[prev_state][i];
                for(o=0; o<rate; o++)
                {
                    if(d_bits[i*rate + o] >= 0)
                    {
                        in_bit = 0;
                    }else{
                        in_bit = 1;
                    }
                    phy_struct->vd_br_metric[j][k] += (phy_struct->vd_st_output[j][k][o]+in_bit)%2;
                    phy_struct->vd_w_metric[j][k]  += fabs(d_bits[i*rate + o]);
                }
            }

            // Keep the smallest branch metric as the path metric, weight the branch metric
            tmp1 = phy_struct->vd_br_metric[j][0] + phy_struct->vd_p_metric[j][0];
            tmp2 = phy_struct->vd_br_metric[j][1] + phy_struct->vd_p_metric[j][1];
            if(tmp1 > tmp2)
            {
                phy_struct->vd_path_metric[j][i+1] = phy_struct->vd_p_metric[j][1] + phy_struct->vd_w_metric[j][1]*phy_struct->vd_br_metric[j][1];
            }else{
                phy_struct->vd_path_metric[j][i+1] = phy_struct->vd_p_metric[j][0] + phy_struct->vd_w_metric[j][0]*phy_struct->vd_br_metric[j][0];
            }
        }
    }

    // Find the minimum metric for the last iteration
    init_min                     = 1000000;
    idx                          = 0;
    phy_struct->vd_tb_state[idx] = 1000000;
    for(i=0; i<(int32)N_states; i++)
    {
        if(phy_struct->vd_path_metric[i][(N_d_bits/rate)] < init_min)
        {
            init_min                       = phy_struct->vd_path_metric[i][(N_d_bits/rate)];
            phy_struct->vd_tb_state[idx++] = i;
        }
    }

    // Traceback to find the minimum path metrics at each iteration
    for(i=(N_d_bits/rate)-1; i>=0; i--)
    {
        prev_state_0 = ((((uint8)phy_struct->vd_tb_state[idx-1])<<1) + 0) % N_states;
        prev_state_1 = ((((uint8)phy_struct->vd_tb_state[idx-1])<<1) + 1) % N_states;

        // Keep the smallest state
        if(phy_struct->vd_path_metric[prev_state_0][i] > phy_struct->vd_path_metric[prev_state_1][i])
        {
            phy_struct->vd_tb_state[idx++] = prev_state_1;
        }else{
            phy_struct->vd_tb_state[idx++] = prev_state_0;
        }
    }
    tb_state_len = idx;

    // Read through the traceback to determine the input bits
    idx = 0;
    for(i=tb_state_len-2; i>=0; i--)
    {
        // If transition has resulted in a lower valued state,
        // the output is 0 and vice-versa
        if(phy_struct->vd_tb_state[i] < phy_struct->vd_tb_state[i+1])
        {
            c_bits[idx++] = 0;
        }else if(phy_struct->vd_tb_state[i] > phy_struct->vd_tb_state[i+1]){
            c_bits[idx++] = 1;
        }else{
            // Check to see if the transition has resulted in the same state
            // In this case, if state is 0 then output is 0
            if(phy_struct->vd_tb_state[i] == 0)
            {
                c_bits[idx++] = 0;
            }else{
                c_bits[idx++] = 1;
            }
        }
    }
    *N_c_bits = idx;
}

/*********************************************************************
    Name: turbo_encode

    Description: Turbo encodes a bit array using the LTE Parallel
                 Concatenated Convolutional Code

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.3.2

    Notes: Currently not handling filler bits
*********************************************************************/
void turbo_encode(LIBLTE_PHY_STRUCT *phy_struct,
                  uint8             *c_bits,
                  uint32             N_c_bits,
                  uint32             N_fill_bits,
                  uint8             *d_bits,
                  uint32            *N_d_bits)
{
    uint32 i;
    uint32 N_branch_bits = N_c_bits + 4;

    // Construct z
    turbo_constituent_encoder(c_bits,
                              N_c_bits,
                              phy_struct->te_z,
                              phy_struct->te_fb1);

    // Construct c_prime
    turbo_internal_interleaver(c_bits,
                               N_c_bits,
                               phy_struct->te_c_prime);

    // Construct z_prime
    turbo_constituent_encoder(phy_struct->te_c_prime,
                              N_c_bits,
                              phy_struct->te_z_prime,
                              phy_struct->te_x_prime);

    // Construct d_bits
    for(i=0; i<N_c_bits; i++)
    {
        d_bits[i]                 = c_bits[i];
        d_bits[N_branch_bits+i]   = phy_struct->te_z[i];
        d_bits[2*N_branch_bits+i] = phy_struct->te_z_prime[i];
    }
    d_bits[N_c_bits]                   = phy_struct->te_fb1[N_c_bits];
    d_bits[N_c_bits+1]                 = phy_struct->te_z[N_c_bits+1];
    d_bits[N_c_bits+2]                 = phy_struct->te_x_prime[N_c_bits];
    d_bits[N_c_bits+3]                 = phy_struct->te_z_prime[N_c_bits+1];
    d_bits[N_branch_bits+N_c_bits]     = phy_struct->te_z[N_c_bits];
    d_bits[N_branch_bits+N_c_bits+1]   = phy_struct->te_fb1[N_c_bits+2];
    d_bits[N_branch_bits+N_c_bits+2]   = phy_struct->te_z_prime[N_c_bits];
    d_bits[N_branch_bits+N_c_bits+3]   = phy_struct->te_x_prime[N_c_bits+2];
    d_bits[2*N_branch_bits+N_c_bits]   = phy_struct->te_fb1[N_c_bits+1];
    d_bits[2*N_branch_bits+N_c_bits+1] = phy_struct->te_z[N_c_bits+1];
    d_bits[2*N_branch_bits+N_c_bits+2] = phy_struct->te_x_prime[N_c_bits+1];
    d_bits[2*N_branch_bits+N_c_bits+3] = phy_struct->te_z_prime[N_c_bits+2];

    *N_d_bits = N_branch_bits*3;
}

/*********************************************************************
    Name: turbo_decode

    Description: Turbo decodes data according to the LTE Parallel
                 Concatenated Convolutional Code.  The design of this
                 decoder is based on the conversion of the constituent
                 coder from:
                                   -------->+---------------->+---- out
                                   |        ^                 ^
                           in_act  |   |-|  |   |-|      |-|  |
                 in --->+------------->|D|----->|D|----->|D|---
                        ^              |-|      |-|  |   |-|  |
                        |                            v        |
                        -----------------------------+<--------
                 to:
                           ------->+---------------->+------------- out
                           |       ^                 ^
                           |  |-|  |   |-|      |-|  |       
                 in_act ------|D|----->|D|----->|D|---         
                           |  |-|      |-|  |   |-|  |          
                           |                v        v         
                           ---------------->+------->+------------- in
                 in_act can be determined using viterbi decoding and
                 a second copy of in can be calculated using in_act

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.3.2

    Notes: Currently not handling filler bits
*********************************************************************/
void turbo_decode(LIBLTE_PHY_STRUCT *phy_struct,
                  float             *d_bits,
                  uint32             N_d_bits,
                  uint32             N_fill_bits,
                  uint8             *c_bits,
                  uint32            *N_c_bits)
{
    float  tmp_s_bit;
    uint32 i;
    uint32 N_bits;
    uint32 N_branch_bits = N_d_bits/3;
    uint32 g_1           = 03; // Numbers are in octal
    uint32 g_2[2]        = {015, 013}; // Numbers are in octal

    // Step 1: Calculate in_act_1 using d0 and d1
    for(i=0; i<N_branch_bits-4; i++)
    {
        phy_struct->td_vitdec_in[i*2+0] = d_bits[i*3+0];
        phy_struct->td_vitdec_in[i*2+1] = d_bits[i*3+1];
    }
    viterbi_decode(phy_struct,
                   phy_struct->td_vitdec_in,
                   (N_branch_bits-4)*2,
                   4,
                   2,
                   g_2,
                   phy_struct->td_in_act_1,
                   &N_bits);

    // Step 2: Calculate fb_1 using in_act_1
    phy_struct->td_fb_1[0] = 0;
    conv_encode(phy_struct,
                phy_struct->td_in_act_1,
                N_branch_bits-4,
                3,
                1,
                &g_1,
                false,
                phy_struct->td_fb_1,
                &N_bits);

    // Step 3: Calculate in_calc_1 using in_act_1 and fb_1
    for(i=0; i<N_branch_bits-4; i++)
    {
        phy_struct->td_in_calc_1[i] = 1-2*(float)((phy_struct->td_in_act_1[i] + phy_struct->td_fb_1[i])%2);
    }

    // Step 4: Calculate in_int using d0
    turbo_internal_interleaver(d_bits,
                               N_branch_bits-4,
                               phy_struct->td_in_int);

    // Step 5: Calculate in_int_1 using in_calc_1
    turbo_internal_interleaver(phy_struct->td_in_calc_1,
                               N_branch_bits-4,
                               phy_struct->td_in_int_1);

    // Step 6: Calculate int_act_1 using in_int and d2
    for(i=0; i<N_branch_bits-4; i++)
    {
        phy_struct->td_vitdec_in[2*i+0] = d_bits[i*3+2];
        phy_struct->td_vitdec_in[2*i+1] = phy_struct->td_in_int[i];
    }
    viterbi_decode(phy_struct,
                   phy_struct->td_vitdec_in,
                   (N_branch_bits-4)*2,
                   4,
                   2,
                   g_2,
                   phy_struct->td_int_act_1,
                   &N_bits);

    // Step 7: Calculate int_act_2 using in_int_1 and d2
    for(i=0; i<N_branch_bits-4; i++)
    {
        phy_struct->td_vitdec_in[2*i+0] = d_bits[i*3+2];
        phy_struct->td_vitdec_in[2*i+1] = phy_struct->td_in_int_1[i];
    }
    viterbi_decode(phy_struct,
                   phy_struct->td_vitdec_in,
                   (N_branch_bits-4)*2,
                   4,
                   2,
                   g_2,
                   phy_struct->td_int_act_2,
                   &N_bits);

    // Step 8: Calculate fb_int_1 using int_act_1
    phy_struct->td_fb_int_1[0] = 0;
    conv_encode(phy_struct,
                phy_struct->td_int_act_1,
                N_branch_bits-4,
                3,
                1,
                &g_1,
                false,
                &phy_struct->td_fb_int_1[1],
                &N_bits);

    // Step 9: Calculate fb_int_2 using int_act_2
    phy_struct->td_fb_int_2[0] = 0;
    conv_encode(phy_struct,
                phy_struct->td_int_act_2,
                N_branch_bits-4,
                3,
                1,
                &g_1,
                false,
                &phy_struct->td_fb_int_2[1],
                &N_bits);

    // Step 10: Calculate int_calc_1 using int_act_1 and fb_int_1
    for(i=0; i<N_branch_bits-4; i++)
    {
        phy_struct->td_int_calc_1[i] = 1-2*(float)((phy_struct->td_int_act_1[i] +
                                                    phy_struct->td_fb_int_1[i]) % 2);
    }

    // Step 11: Calculate int_calc_2 using int_act_2 and fb_int_2
    for(i=0; i<N_branch_bits-4; i++)
    {
        phy_struct->td_int_calc_2[i] = 1-2*(float)((phy_struct->td_int_act_2[i] +
                                                    phy_struct->td_fb_int_2[i]) % 2);
    }

    // Step 12: Calculate in_calc_2 using int_calc_1
    turbo_internal_deinterleaver(phy_struct->td_int_calc_1,
                                 N_branch_bits-4,
                                 phy_struct->td_in_calc_2);

    // Step 13: Calculate in_calc_3 using int_calc_2
    turbo_internal_deinterleaver(phy_struct->td_int_calc_2,
                                 N_branch_bits-4,
                                 phy_struct->td_in_calc_3);

    // Step 14: Soft combine d0, in_calc_1, in_calc_2, and in_calc_3 to get output
    for(i=0; i<N_branch_bits-4; i++)
    {
        tmp_s_bit = (d_bits[i*3+0]               +
                     phy_struct->td_in_calc_1[i] +
                     phy_struct->td_in_calc_2[i] +
                     phy_struct->td_in_calc_3[i]);
        if(tmp_s_bit >= 0)
        {
            c_bits[i] = 0;
        }else{
            c_bits[i] = 1;
        }
    }
}

/*********************************************************************
    Name: turbo_constituent_encoder

    Description: Constituent encoder for the LTE Parallel Concatenated
                 Convolutional Code

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.3.2
*********************************************************************/
void turbo_constituent_encoder(uint8  *in_bits,
                               uint32  N_in_bits,
                               uint8  *out_bits,
                               uint8  *fb_bits)
{
    uint32 i;
    uint32 j;
    uint32 constraint_len = 4;
    uint8  s_reg[4]    = {0,0,0,0};
    uint8  g_array[4]  = {1,1,0,1};
    uint8  fb_array[4] = {0,0,1,1};

    // Convolutionally encode input
    for(i=0; i<N_in_bits; i++)
    {
        // Sequence the shift register
        for(j=constraint_len-1; j<0; j--)
        {
            s_reg[j] = s_reg[j-1];
        }

        // Calculate the feedback bit
        fb_bits[i] = 0;
        for(j=0; j<constraint_len; j++)
        {
            fb_bits[i] += s_reg[j]*fb_array[j];
        }
        fb_bits[i] %= 2;

        // Add the next bit to the shift register
        s_reg[0] = (fb_bits[i] + in_bits[i]) % 2;

        // Calculate the output bit
        out_bits[i] = 0;
        for(j=0; j<constraint_len; j++)
        {
            out_bits[i] += s_reg[j]*g_array[j];
        }
        out_bits[i] %= 2;
    }

    // Trellis termination
    for(i=N_in_bits; i<N_in_bits+4; i++)
    {
        // Sequence the shift register
        for(j=constraint_len-1; j<0; j--)
        {
            s_reg[j] = s_reg[j-1];
        }

        // Calculate the feedback bit
        fb_bits[i] = 0;
        for(j=0; j<constraint_len; j++)
        {
            fb_bits[i] += s_reg[j]*fb_array[j];
        }
        fb_bits[i] %= 2;

        // Add the next bit to the shift register
        s_reg[0] = (fb_bits[i] + fb_bits[i]) % 2;

        // Calculate the output bit
        out_bits[i] = 0;
        for(j=0; j<constraint_len; j++)
        {
            out_bits[i] += s_reg[j]*g_array[j];
        }
        out_bits[i] %= 2;
    }
}

/*********************************************************************
    Name: turbo_internal_interleaver

    Description: Internal interleaver for the LTE Parallel
                 Concatenated Convolutional Code

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.3.2
*********************************************************************/
void turbo_internal_interleaver(uint8  *in_bits,
                                uint32  N_in_bits,
                                uint8  *out_bits)
{
    uint32 i;
    uint32 f1 = 0;
    uint32 f2 = 0;
    uint32 idx;

    // Determine f1 and f2
    for(i=0; i<TURBO_INT_K_TABLE_SIZE; i++)
    {
        if(N_in_bits == TURBO_INT_K_TABLE[i])
        {
            f1 = TURBO_INT_F1_TABLE[i];
            f2 = TURBO_INT_F2_TABLE[i];
            break;
        }
    }

    for(i=0; i<N_in_bits; i++)
    {
        idx         = (f1*i + f2*i*i) % N_in_bits;
        out_bits[i] = in_bits[idx];
    }
}
void turbo_internal_interleaver(float  *in_bits,
                                uint32  N_in_bits,
                                float  *out_bits)
{
    uint32 i;
    uint32 f1 = 0;
    uint32 f2 = 0;
    uint32 idx;

    // Determine f1 and f2
    for(i=0; i<TURBO_INT_K_TABLE_SIZE; i++)
    {
        if(N_in_bits == TURBO_INT_K_TABLE[i])
        {
            f1 = TURBO_INT_F1_TABLE[i];
            f2 = TURBO_INT_F2_TABLE[i];
            break;
        }
    }

    for(i=0; i<N_in_bits; i++)
    {
        idx         = (f1*i + f2*i*i) % N_in_bits;
        out_bits[i] = in_bits[idx];
    }
}

/*********************************************************************
    Name: turbo_internal_deinterleaver

    Description: Internal Deinterleaver for the LTE Parallel
                 Concatenated Convolutional Code

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.3.2
*********************************************************************/
void turbo_internal_deinterleaver(float  *in_bits,
                                  uint32  N_in_bits,
                                  float  *out_bits)
{
    uint32 i;
    uint32 f1 = 0;
    uint32 f2 = 0;
    uint32 idx;

    // Determine f1 and f2
    for(i=0; i<TURBO_INT_K_TABLE_SIZE; i++)
    {
        if(N_in_bits == TURBO_INT_K_TABLE[i])
        {
            f1 = TURBO_INT_F1_TABLE[i];
            f2 = TURBO_INT_F2_TABLE[i];
            break;
        }
    }

    for(i=0; i<N_in_bits; i++)
    {
        idx           = (f1*i + f2*i*i) % N_in_bits;
        out_bits[idx] = in_bits[i];
    }
}

/*********************************************************************
    Name: rate_match_turbo

    Description: Rate matches turbo encoded data

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.4.1
*********************************************************************/
void rate_match_turbo(LIBLTE_PHY_STRUCT         *phy_struct,
                      uint8                     *d_bits,
                      uint32                     N_d_bits,
                      uint32                     N_codeblocks,
                      uint32                     tx_mode,
                      uint32                     N_soft,
                      uint32                     M_dl_harq,
                      LIBLTE_PHY_CHAN_TYPE_ENUM  chan_type,
                      uint32                     rv_idx,
                      uint32                     N_e_bits,
                      uint8                     *e_bits)
{
    uint32 C_tc_sb = 32; // Step 1: Assign C_tc_sb to 32
    uint32 R_tc_sb;
    uint32 w_idx = 0;
    uint32 d_idx;
    uint32 pi_idx;
    uint32 N_dummy;
    uint32 K_mimo;
    uint32 N_ir;
    uint32 N_cb;
    uint32 idx;
    uint32 K_pi;
    uint32 K_w;
    uint32 k_0;
    uint32 i;
    uint32 j;
    uint32 k;
    uint32 x;

    // Sub-block interleaving
    // Step 2: Determine the number of rows
    R_tc_sb = 0;
    while(N_d_bits > (C_tc_sb*R_tc_sb))
    {
        R_tc_sb++;
    }

    // Steps 3, 4, and 5
    for(x=0; x<3; x++)
    {
        // Step 3: Pack data into matrix and pad with dummy
        if(N_d_bits < (C_tc_sb*R_tc_sb))
        {
            N_dummy = C_tc_sb*R_tc_sb - N_d_bits;
        }else{
            N_dummy = 0;
        }
        for(i=0; i<N_dummy; i++)
        {
            phy_struct->rmt_tmp[i] = TX_NULL_BIT;
        }
        d_idx = 0;
        for(i=N_dummy; i<C_tc_sb*R_tc_sb; i++)
        {
            phy_struct->rmt_tmp[i] = d_bits[d_idx*3+x];
            d_idx++;
        }
        idx = 0;
        for(i=0; i<R_tc_sb; i++)
        {
            for(j=0; j<C_tc_sb; j++)
            {
                phy_struct->rmt_sb_mat[i][j] = phy_struct->rmt_tmp[idx++];
            }
        }

        if(x != 2)
        {
            // Step 4: Inter-column permutation
            for(i=0; i<R_tc_sb; i++)
            {
                for(j=0; j<C_tc_sb; j++)
                {
                    phy_struct->rmt_sb_perm_mat[i][j] = phy_struct->rmt_sb_mat[i][IC_PERM_TC[j]];
                }
            }

            // Step 5: Read out the bits
            idx = 0;
            for(j=0; j<C_tc_sb; j++)
            {
                for(i=0; i<R_tc_sb; i++)
                {
                    phy_struct->rmt_w[w_idx++] = phy_struct->rmt_sb_perm_mat[i][j];
                }
            }
            K_pi = R_tc_sb*C_tc_sb;
        }else{
            // Step 4: Permutation for the last output
            K_pi = R_tc_sb*C_tc_sb;
            idx  = 0;
            for(i=0; i<R_tc_sb; i++)
            {
                for(j=0; j<C_tc_sb; j++)
                {
                    phy_struct->rmt_y[idx++] = phy_struct->rmt_sb_mat[i][j];
                }
            }
            for(i=0; i<K_pi; i++)
            {
                pi_idx                     = (IC_PERM_TC[i/R_tc_sb]+C_tc_sb*(i%R_tc_sb)+1) % K_pi;
                phy_struct->rmt_w[w_idx++] = phy_struct->rmt_y[pi_idx];
            }
        }
    }

    // Bit collection, selection, and transmission
    // Create circular buffer
    K_w = 3*K_pi;
    if(tx_mode == 3 ||
       tx_mode == 4 ||
       tx_mode == 8 ||
       tx_mode == 9)
    {
        K_mimo = 2;
    }else{
        K_mimo = 1;
    }
    if(M_dl_harq < 8)
    {
        N_ir = N_soft/(K_mimo*M_dl_harq);
    }else{
        N_ir = N_soft/(K_mimo*8);
    }
    if(LIBLTE_PHY_CHAN_TYPE_DLSCH == chan_type ||
       LIBLTE_PHY_CHAN_TYPE_PCH   == chan_type)
    {
        if((N_ir/N_codeblocks) < K_w)
        {
            N_cb = N_ir/N_codeblocks;
        }else{
            N_cb = K_w;
        }
    }else{
        N_cb = K_w;
    }
    k_0 = R_tc_sb*(2*(uint32)ceilf((float)N_cb/(float)(8*R_tc_sb))*rv_idx+2);
    k   = 0;
    j   = 0;
    while(k < N_e_bits)
    {
        if(phy_struct->rmt_w[(k_0+j)%N_cb] != TX_NULL_BIT)
        {
            e_bits[k++] = phy_struct->rmt_w[(k_0+j)%N_cb];
        }
        j++;
    }
}

/*********************************************************************
    Name: rate_unmatch_turbo

    Description: Rate unmatches turbo encoded data

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.4.1
*********************************************************************/
void rate_unmatch_turbo(LIBLTE_PHY_STRUCT         *phy_struct,
                        float                     *e_bits,
                        uint32                     N_e_bits,
                        uint8                     *dummy_bits,
                        uint32                     N_dummy_bits,
                        uint32                     N_codeblocks,
                        uint32                     tx_mode,
                        uint32                     N_soft,
                        uint32                     M_dl_harq,
                        LIBLTE_PHY_CHAN_TYPE_ENUM  chan_type,
                        uint32                     rv_idx,
                        float                     *d_bits,
                        uint32                    *N_d_bits)
{
    uint32 C_tc_sb = 32; // Step 1: Assign C_tc_sb to 32
    uint32 R_tc_sb;
    uint32 w_idx = 0;
    uint32 d_idx;
    uint32 pi_idx;
    uint32 N_dummy;
    uint32 K_mimo;
    uint32 N_ir;
    uint32 N_cb;
    uint32 idx;
    uint32 K_pi;
    uint32 K_w;
    uint32 k_0;
    uint32 i;
    uint32 j;
    uint32 k;
    uint32 x;

    // In order to undo bit collection, selection, and transmission
    // a dummy block must be sub-block interleaved to determine
    // where NULL bits are to be inserted
    // Sub-block interleaving
    // Step 2: Determine the number of rows
    R_tc_sb = 0;
    while(N_dummy_bits > (C_tc_sb*R_tc_sb))
    {
        R_tc_sb++;
    }

    // Steps 3, 4, and 5
    for(x=0; x<3; x++)
    {
        // Step 3: Pack data into matrix and pad with dummy
        if(N_dummy_bits < (C_tc_sb*R_tc_sb))
        {
            N_dummy = C_tc_sb*R_tc_sb - N_dummy_bits;
        }else{
            N_dummy = 0;
        }
        for(i=0; i<N_dummy; i++)
        {
            phy_struct->rut_tmp[i] = RX_NULL_BIT;
        }
        d_idx = 0;
        for(i=N_dummy; i<N_dummy_bits; i++)
        {
            phy_struct->rut_tmp[i] = dummy_bits[d_idx*3+x];
            d_idx++;
        }
        idx = 0;
        for(i=0; i<R_tc_sb; i++)
        {
            for(j=0; j<C_tc_sb; j++)
            {
                phy_struct->rut_sb_mat[i][j] = phy_struct->rut_tmp[idx++];
            }
        }

        if(x != 2)
        {
            // Step 4: Inter-column permutation
            for(i=0; i<R_tc_sb; i++)
            {
                for(j=0; j<C_tc_sb; j++)
                {
                    phy_struct->rut_sb_perm_mat[i][j] = phy_struct->rut_sb_mat[i][IC_PERM_TC[j]];
                }
            }

            // Step 5: Read out the bits
            for(j=0; j<C_tc_sb; j++)
            {
                for(i=0; i<R_tc_sb; i++)
                {
                    phy_struct->rut_w_dum[w_idx] = phy_struct->rut_sb_perm_mat[i][j];
                    phy_struct->rut_w[w_idx]     = RX_NULL_BIT;
                    w_idx++;
                }
            }
            K_pi = R_tc_sb*C_tc_sb;
        }else{
            // Step 4: Permutation for the last output
            K_pi = R_tc_sb*C_tc_sb;
            idx  = 0;
            for(i=0; i<R_tc_sb; i++)
            {
                for(j=0; j<C_tc_sb; j++)
                {
                    phy_struct->rut_y[idx++] = phy_struct->rut_sb_mat[i][j];
                }
            }
            for(i=0; i<K_pi; i++)
            {
                pi_idx                       = (IC_PERM_TC[i/R_tc_sb]+C_tc_sb*(i%R_tc_sb)+1)%K_pi;
                phy_struct->rut_w_dum[w_idx] = phy_struct->rut_y[pi_idx];
                phy_struct->rut_w[w_idx]     = RX_NULL_BIT;
                w_idx++;
            }
        }
    }

    // Undo bit collection, selection, and transmission by
    // recreating the circular buffer
    K_w = 3*K_pi;
    if(tx_mode == 3 ||
       tx_mode == 4 ||
       tx_mode == 8 ||
       tx_mode == 9)
    {
        K_mimo = 2;
    }else{
        K_mimo = 1;
    }
    if(M_dl_harq < 8)
    {
        N_ir = N_soft/(K_mimo*M_dl_harq);
    }else{
        N_ir = N_soft/(K_mimo*8);
    }
    if(LIBLTE_PHY_CHAN_TYPE_DLSCH == chan_type ||
       LIBLTE_PHY_CHAN_TYPE_PCH   == chan_type)
    {
        if((N_ir/N_codeblocks) < K_w)
        {
            N_cb = N_ir/N_codeblocks;
        }else{
            N_cb = K_w;
        }
    }else{
        N_cb = K_w;
    }
    k_0 = R_tc_sb*(2*ceilf((float)N_cb/(float)(8*R_tc_sb))*rv_idx+2);
    k   = 0;
    j   = 0;
    while(k < N_e_bits)
    {
        if(phy_struct->rut_w_dum[(k_0+j)%N_cb] != RX_NULL_BIT)
        {
            // Soft combine the inputs
            if(phy_struct->rut_w[(k_0+j)%N_cb] == RX_NULL_BIT)
            {
                phy_struct->rut_w[(k_0+j)%N_cb] = e_bits[k];
            }else if(e_bits[k] != RX_NULL_BIT){
                phy_struct->rut_w[(k_0+j)%N_cb] += e_bits[k];
            }
            k++;
        }
        j++;
    }

    // Recreate the sub-block interleaver output
    for(i=0; i<K_pi; i++)
    {
        phy_struct->rut_v[0][i] = phy_struct->rut_w[i];
        phy_struct->rut_v[1][i] = phy_struct->rut_w[i+K_pi];
        phy_struct->rut_v[2][i] = phy_struct->rut_w[i+2*K_pi];
    }

    // Sub-block deinterleaving
    // Steps 5, 4, and 3
    for(x=0; x<3; x++)
    {
        if(x != 2)
        {
            // Step 5: Load the permuted matrix
            idx = 0;
            for(j=0; j<C_tc_sb; j++)
            {
                for(i=0; i<R_tc_sb; i++)
                {
                    phy_struct->rut_sb_perm_mat[i][j] = phy_struct->rut_v[x][idx++];
                }
            }

            // Step 4: Undo permutation
            for(i=0; i<R_tc_sb; i++)
            {
                for(j=0; j<C_tc_sb; j++)
                {
                    phy_struct->rut_sb_mat[i][IC_PERM_TC[j]] = phy_struct->rut_sb_perm_mat[i][j];
                }
            }
        }else{
            // Step 4: Permutation for the last output
            for(i=0; i<K_pi; i++)
            {
                pi_idx                    = (IC_PERM_TC[i/R_tc_sb]+C_tc_sb*(i%R_tc_sb)+1) % K_pi;
                phy_struct->rut_y[pi_idx] = phy_struct->rut_v[x][i];
            }
            idx = 0;
            for(i=0; i<R_tc_sb; i++)
            {
                for(j=0; j<C_tc_sb; j++)
                {
                    phy_struct->rut_sb_mat[i][j] = phy_struct->rut_y[idx++];
                }
            }
        }

        // Step 3: Unpack the data and remove dummy
        if(N_dummy_bits < (C_tc_sb*R_tc_sb))
        {
            N_dummy = C_tc_sb*R_tc_sb - N_dummy_bits;
        }else{
            N_dummy = 0;
        }
        idx = 0;
        for(i=0; i<R_tc_sb; i++)
        {
            for(j=0; j<C_tc_sb; j++)
            {
                phy_struct->rut_tmp[idx++] = phy_struct->rut_sb_mat[i][j];
            }
        }
        d_idx = 0;
        for(i=N_dummy; i<C_tc_sb*R_tc_sb; i++)
        {
            d_bits[d_idx*3+x] = phy_struct->rut_tmp[i];
            d_idx++;
        }
    }
    *N_d_bits = d_idx*3;
}

/*********************************************************************
    Name: rate_match_conv

    Description: Rate matches convolutionally encoded data

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.4.2
*********************************************************************/
void rate_match_conv(LIBLTE_PHY_STRUCT *phy_struct,
                     uint8             *d_bits,
                     uint32             N_d_bits,
                     uint32             N_e_bits,
                     uint8             *e_bits)
{
    uint32 C_cc_sb = 32; // Step 1: Assign C_cc_sb to 32
    uint32 R_cc_sb;
    uint32 w_idx = 0;
    uint32 d_idx;
    uint32 N_dummy;
    uint32 idx;
    uint32 K_pi;
    uint32 K_w;
    uint32 i;
    uint32 j;
    uint32 k;
    uint32 x;

    // Sub-block interleaving
    // Step 2: Determine the number of rows
    R_cc_sb = 0;
    while(N_d_bits > (C_cc_sb*R_cc_sb))
    {
        R_cc_sb++;
    }

    // Steps 3, 4, and 5
    for(x=0; x<3; x++)
    {
        // Step 3: Pack data into matrix and pad with dummy
        if(N_d_bits < (C_cc_sb*R_cc_sb))
        {
            N_dummy = C_cc_sb*R_cc_sb - N_d_bits;
        }else{
            N_dummy = 0;
        }
        for(i=0; i<N_dummy; i++)
        {
            phy_struct->rmc_tmp[i] = TX_NULL_BIT;
        }
        d_idx = 0;
        for(i=N_dummy; i<C_cc_sb*R_cc_sb; i++)
        {
            phy_struct->rmc_tmp[i] = d_bits[d_idx*3+x];
            d_idx++;
        }
        idx = 0;
        for(i=0; i<R_cc_sb; i++)
        {
            for(j=0; j<C_cc_sb; j++)
            {
                phy_struct->rmc_sb_mat[i][j] = phy_struct->rmc_tmp[idx++];
            }
        }

        // Step 4: Inter-column permutation
        for(i=0; i<R_cc_sb; i++)
        {
            for(j=0; j<C_cc_sb; j++)
            {
                phy_struct->rmc_sb_perm_mat[i][j] = phy_struct->rmc_sb_mat[i][IC_PERM_CC[j]];
            }
        }

        // Step 5: Read out the bits
        for(j=0; j<C_cc_sb; j++)
        {
            for(i=0; i<R_cc_sb; i++)
            {
                phy_struct->rmc_w[w_idx++] = phy_struct->rmc_sb_perm_mat[i][j];
            }
        }
    }
    K_pi = R_cc_sb*C_cc_sb;

    // Bit collection, selection, and transmission
    // Create circular buffer
    K_w = 3*K_pi;
    k   = 0;
    j   = 0;
    while(k < N_e_bits)
    {
        if(phy_struct->rmc_w[j%K_w] != TX_NULL_BIT)
        {
            e_bits[k++] = phy_struct->rmc_w[j%K_w];
        }
        j++;
    }
}

/*********************************************************************
    Name: rate_unmatch_conv

    Description: Rate unmatches convolutionally encoded data

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.4.2
*********************************************************************/
void rate_unmatch_conv(LIBLTE_PHY_STRUCT *phy_struct,
                       float             *e_bits,
                       uint32             N_e_bits,
                       uint32             N_c_bits,
                       float             *d_bits,
                       uint32            *N_d_bits)
{
    uint32 C_cc_sb = 32; // Step 1: Assign C_cc_sb to 32
    uint32 R_cc_sb;
    uint32 w_idx = 0;
    uint32 d_idx;
    uint32 N_dummy;
    uint32 idx;
    uint32 K_pi;
    uint32 K_w;
    uint32 i;
    uint32 j;
    uint32 k;
    uint32 x;

    // In order to undo bit collection, selection, and transmission
    // a dummy block must be sub-block interleaved to determine
    // where NULL bits are to be inserted
    // Sub-block interleaving
    // Step 2: Determine the number of rows
    R_cc_sb = 0;
    while(N_c_bits > (C_cc_sb*R_cc_sb))
    {
        R_cc_sb++;
    }

    // Steps 3, 4, and 5
    for(x=0; x<3; x++)
    {
        // Step 3: Pack data into matrix and pad with dummy
        if(N_c_bits < (C_cc_sb*R_cc_sb))
        {
            N_dummy = C_cc_sb*R_cc_sb - N_c_bits;
        }else{
            N_dummy = 0;
        }
        for(i=0; i<N_dummy; i++)
        {
            phy_struct->ruc_tmp[i] = RX_NULL_BIT;
        }
        for(i=N_dummy; i<N_c_bits; i++)
        {
            phy_struct->ruc_tmp[i] = 0;
        }
        idx = 0;
        for(i=0; i<R_cc_sb; i++)
        {
            for(j=0; j<C_cc_sb; j++)
            {
                phy_struct->ruc_sb_mat[i][j] = phy_struct->ruc_tmp[idx++];
            }
        }

        // Step 4: Inter-column permutation
        for(i=0; i<R_cc_sb; i++)
        {
            for(j=0; j<C_cc_sb; j++)
            {
                phy_struct->ruc_sb_perm_mat[i][j] = phy_struct->ruc_sb_mat[i][IC_PERM_CC[j]];
            }
        }

        // Step 5: Read out the bits
        for(j=0; j<C_cc_sb; j++)
        {
            for(i=0; i<R_cc_sb; i++)
            {
                phy_struct->ruc_w_dum[w_idx] = phy_struct->ruc_sb_perm_mat[i][j];
                phy_struct->ruc_w[w_idx]     = RX_NULL_BIT;
                w_idx++;
            }
        }
    }

    // Undo bit collection, selection, and transmission by
    // recreating the circular buffer
    K_pi = R_cc_sb*C_cc_sb;
    K_w  = 3*K_pi;
    k    = 0;
    j    = 0;
    while(k < N_e_bits)
    {
        if(phy_struct->ruc_w_dum[j%K_w] != RX_NULL_BIT)
        {
            // Soft combine the inputs
            if(phy_struct->ruc_w[j%K_w] == RX_NULL_BIT)
            {
                phy_struct->ruc_w[j%K_w] = e_bits[k];
            }else if(e_bits[k] != RX_NULL_BIT){
                phy_struct->ruc_w[j%K_w] += e_bits[k];
            }
            k++;
        }
        j++;
    }

    // Recreate the sub-block interleaver output
    for(i=0; i<K_pi; i++)
    {
        phy_struct->ruc_v[0][i] = phy_struct->ruc_w[i];
        phy_struct->ruc_v[1][i] = phy_struct->ruc_w[i+K_pi];
        phy_struct->ruc_v[2][i] = phy_struct->ruc_w[i+2*K_pi];
    }

    // Sub-block deinterleaving
    // Steps 5, 4, and 3
    for(x=0; x<3; x++)
    {
        // Step 5: Load the permuted matrix
        idx = 0;
        for(j=0; j<C_cc_sb; j++)
        {
            for(i=0; i<R_cc_sb; i++)
            {
                phy_struct->ruc_sb_perm_mat[i][j] = phy_struct->ruc_v[x][idx++];
            }
        }

        // Step 4: Undo permutation
        for(i=0; i<R_cc_sb; i++)
        {
            for(j=0; j<C_cc_sb; j++)
            {
                phy_struct->ruc_sb_mat[i][IC_PERM_CC[j]] = phy_struct->ruc_sb_perm_mat[i][j];
            }
        }

        // Step 3: Unpack the data and remove dummy
        if(N_c_bits < (C_cc_sb*R_cc_sb))
        {
            N_dummy = C_cc_sb*R_cc_sb - N_c_bits;
        }else{
            N_dummy = 0;
        }
        idx = 0;
        for(i=0; i<R_cc_sb; i++)
        {
            for(j=0; j<C_cc_sb; j++)
            {
                phy_struct->ruc_tmp[idx++] = phy_struct->ruc_sb_mat[i][j];
            }
        }
        d_idx = 0;
        for(i=N_dummy; i<C_cc_sb*R_cc_sb; i++)
        {
            d_bits[d_idx*3+x] = phy_struct->ruc_tmp[i];
            d_idx++;
        }
    }
    *N_d_bits = d_idx*3;
}

/*********************************************************************
    Name: code_block_concatenation

    Description: Performs code block concatenation for turbo coded
                 channels

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.5
*********************************************************************/
void code_block_concatenation(uint8  *e_bits,
                              uint32  N_e_bits,
                              uint32  N_e_bits_max,
                              uint32  N_codeblocks,
                              uint8  *f_bits,
                              uint32 *N_f_bits)
{
    uint32 j = 0;
    uint32 k = 0;
    uint32 r = 0;

    // Concatenate code blocks
    while(r < N_codeblocks)
    {
        while(j < N_e_bits)
        {
            f_bits[k++] = e_bits[r*N_e_bits_max+j];
            j++;
        }
        r++;
    }
}

/*********************************************************************
    Name: code_block_deconcatenation

    Description: Performs code block deconcatenation for turbo coded
                 channels

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.1.5
*********************************************************************/
void code_block_deconcatenation(float  *f_bits,
                                uint32  N_f_bits,
                                uint32  tbs,
                                float  *e_bits,
                                uint32 *N_e_bits,
                                uint32  N_e_bits_max,
                                uint32 *N_codeblocks)
{
    uint32 Z = 6144;
    uint32 L;
    uint32 B;
    uint32 C;
    uint32 F;
    uint32 B_prime;
    uint32 K_plus  = 0;
    uint32 K_minus = 0;
    uint32 K_delta;
    uint32 C_plus;
    uint32 C_minus;
    uint32 j;
    uint32 k;
    uint32 r;
    int32  i;

    // Determine L, C, B', K+, C+, K-, and C-, 3GPP TS 36.212 v10.1.0 section 5.1.2
    if(tbs <= Z)
    {
        L       = 0;
        C       = 1;
        B_prime = N_f_bits;
        for(i=0; i<TURBO_INT_K_TABLE_SIZE; i++)
        {
            if(C*TURBO_INT_K_TABLE[i] >= B_prime)
            {
                K_plus = TURBO_INT_K_TABLE[i];
                break;
            }
        }
        K_minus = 0;
        C_plus  = 1;
        C_minus = 0;
    }else{
        B       = tbs + 24;
        L       = 24;
        C       = (uint32)ceilf((float)B/(float)(Z-L));
        B_prime = B + C*L;
        for(i=0; i<TURBO_INT_K_TABLE_SIZE; i++)
        {
            if(C*TURBO_INT_K_TABLE[i] >= B_prime)
            {
                K_plus = TURBO_INT_K_TABLE[i];
                break;
            }
        }
        for(i=TURBO_INT_K_TABLE_SIZE-1; i>=0; i--)
        {
            if(TURBO_INT_K_TABLE[i] < K_plus)
            {
                K_minus = TURBO_INT_K_TABLE[i];
                break;
            }
        }
        K_delta = K_plus - K_minus;
        C_minus = (C*K_plus - B_prime)/K_delta;
        C_plus  = C - C_minus;
    }
    F             = C_plus*K_plus + C_minus*K_minus - B_prime;
    *N_codeblocks = C;

    // Deconcatenate code blocks
    k = 0;
    r = 0;
    while(r < C)
    {
        // Determine the K for this code block
        if(r < C_minus)
        {
            N_e_bits[r] = K_minus;
        }else{
            N_e_bits[r] = K_plus;
        }
        if(C > 1)
        {
            N_e_bits[r] += L;
        }
        // FIXME: Not handling filler bits currently
        N_e_bits[r] -= F;

        j = 0;
        while(j < N_e_bits[r])
        {
            e_bits[r*N_e_bits_max+j] = f_bits[k++];
            j++;
        }
        r++;
    }
}

/*********************************************************************
    Name: bch_channel_encode

    Description: Channel encodes the broadcast channel

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.3.1
*********************************************************************/
void bch_channel_encode(LIBLTE_PHY_STRUCT *phy_struct,
                        uint8             *in_bits,
                        uint32             N_in_bits,
                        uint8              N_ant,
                        uint8             *out_bits,
                        uint32            *N_out_bits)
{
    uint32  i;
    uint32  g[3] = {0133, 0171, 0165}; // Numbers are in octal
    uint32  N_d_bits;
    uint8  *ant_mask = NULL;
    uint8  *a_bits   = NULL;
    uint8   p_bits[16];
    uint8   ant_mask_1[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    uint8   ant_mask_2[16] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
    uint8   ant_mask_4[16] = {0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1};

    if(N_ant == 1)
    {
        ant_mask = ant_mask_1;
    }else if(N_ant == 2){
        ant_mask = ant_mask_2;
    }else{
        ant_mask = ant_mask_4;
    }

    // Define a_bits
    a_bits = in_bits;

    // Calculate p_bits
    calc_crc(a_bits, 24, CRC16, p_bits, 16);

    // Mask p_bits
    for(i=0; i<16; i++)
    {
        p_bits[i] = p_bits[i] ^ ant_mask[i];
    }

    // Construct c_bits
    for(i=0; i<24; i++)
    {
        phy_struct->bch_c_bits[i] = a_bits[i];
    }
    for(i=0; i<16; i++)
    {
        phy_struct->bch_c_bits[24+i] = p_bits[i];
    }

    // Determine d_bits
    conv_encode(phy_struct,
                phy_struct->bch_c_bits,
                40,
                7,
                3,
                g,
                true,
                phy_struct->bch_tx_d_bits,
                &N_d_bits);

    // Determine e_bits
    rate_match_conv(phy_struct, phy_struct->bch_tx_d_bits, N_d_bits, 1920, out_bits);
    *N_out_bits = 1920;
}

/*********************************************************************
    Name: bch_channel_decode

    Description: Channel decodes the broadcast channel

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.3.1
*********************************************************************/
LIBLTE_ERROR_ENUM bch_channel_decode(LIBLTE_PHY_STRUCT *phy_struct,
                                     float             *in_bits,
                                     uint32             N_in_bits,
                                     uint8             *N_ant,
                                     uint8             *out_bits,
                                     uint32            *N_out_bits)
{
    LIBLTE_ERROR_ENUM  err = LIBLTE_ERROR_INVALID_CRC;
    uint32             ber_1;
    uint32             ber_2;
    uint32             ber_4;
    uint32             N_d_bits;
    uint32             N_c_bits;
    uint32             i;
    uint32             g[3] = {0133, 0171, 0165}; // Numbers are in octal
    uint8             *a_bits;
    uint8             *p_bits;
    uint8              calc_p_bits[16];
    uint8              ant_mask_1[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    uint8              ant_mask_2[16] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
    uint8              ant_mask_4[16] = {0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1};

    // Rate unmatch to get the d_bits
    rate_unmatch_conv(phy_struct,
                      in_bits,
                      N_in_bits,
                      40,
                      phy_struct->bch_rx_d_bits,
                      &N_d_bits);

    // Viterbi decode the d_bits to get the c_bits
    viterbi_decode(phy_struct,
                   phy_struct->bch_rx_d_bits,
                   N_d_bits,
                   7,
                   3,
                   g,
                   phy_struct->bch_c_bits,
                   &N_c_bits);

    // Recover a_bits and p_bits
    a_bits = &phy_struct->bch_c_bits[0];
    p_bits = &phy_struct->bch_c_bits[24];

    // Calculate p_bits
    calc_crc(a_bits, 24, CRC16, calc_p_bits, 16);

    // Try all p_bit masks
    ber_1 = 0;
    ber_2 = 0;
    ber_4 = 0;
    for(i=0; i<16; i++)
    {
        ber_1 += p_bits[i] ^ (calc_p_bits[i] ^ ant_mask_1[i]);
        ber_2 += p_bits[i] ^ (calc_p_bits[i] ^ ant_mask_2[i]);
        ber_4 += p_bits[i] ^ (calc_p_bits[i] ^ ant_mask_4[i]);
    }

    if(ber_1 == 0 || ber_2 == 0 || ber_4 == 0)
    {
        for(i=0; i<24; i++)
        {
            out_bits[i] = a_bits[i];
        }
        *N_out_bits = 24;
        err         = LIBLTE_SUCCESS;
    }
    if(ber_1 == 0)
    {
        *N_ant = 1;
    }else if(ber_2 == 0){
        *N_ant = 2;
    }else if(ber_4 == 0){
        *N_ant = 4;
    }

    return(err);
}

/*********************************************************************
    Name: dlsch_channel_encode

    Description: Channel encodes the Downlink Shared Channel

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.3.2
*********************************************************************/
void dlsch_channel_encode(LIBLTE_PHY_STRUCT *phy_struct,
                          uint8             *in_bits,
                          uint32             N_in_bits,
                          uint32             tx_mode,
                          uint32             rv_idx,
                          uint32             G,
                          uint32             N_l,
                          uint32             Q_m,
                          uint32             M_dl_harq,
                          uint32             N_soft,
                          uint8             *out_bits,
                          uint32            *N_out_bits)
{
    // FIXME
}

/*********************************************************************
    Name: dlsch_channel_decode

    Description: Channel decodes the Downlink Shared Channel

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.3.2
*********************************************************************/
LIBLTE_ERROR_ENUM dlsch_channel_decode(LIBLTE_PHY_STRUCT *phy_struct,
                                       float             *in_bits,
                                       uint32             N_in_bits,
                                       uint32             tbs,
                                       uint32             tx_mode,
                                       uint32             rv_idx,
                                       uint32             M_dl_harq,
                                       uint32             N_soft,
                                       uint8             *out_bits,
                                       uint32            *N_out_bits)
{
    LIBLTE_ERROR_ENUM  err = LIBLTE_ERROR_INVALID_CRC;
    uint32             i;
    uint32             cb;
    uint32             ber;
    uint32             N_b_bits;
    uint32             N_d_bits;
    uint32             N_fill_bits;
    uint32             N_codeblocks;
    uint8              calc_p_bits[24];
    uint8             *a_bits;
    uint8             *p_bits;

    // In order to decode a DLSCH message, the NULL bit pattern must be
    // determined by encoding a sequence of zeros
    N_b_bits = tbs+24;
    memset(phy_struct->dlsch_b_bits, 0, sizeof(uint8)*N_b_bits);
    code_block_segmentation(phy_struct->dlsch_b_bits,
                            N_b_bits,
                            &N_codeblocks,
                            &N_fill_bits,
                            phy_struct->dlsch_c_bits[0],
                            6144,
                            phy_struct->dlsch_N_c_bits);

    // Determine e_bits
    code_block_deconcatenation(in_bits,
                               N_in_bits,
                               tbs,
                               phy_struct->dlsch_rx_e_bits[0],
                               phy_struct->dlsch_N_e_bits,
                               18432,
                               &N_codeblocks);

    for(cb=0; cb<N_codeblocks; cb++)
    {
        // Construct dummy_d_bits
        turbo_encode(phy_struct,
                     phy_struct->dlsch_c_bits[cb],
                     phy_struct->dlsch_N_c_bits[cb],
                     N_fill_bits,
                     phy_struct->dlsch_tx_d_bits,
                     &N_d_bits);

        // Determine d_bits
        rate_unmatch_turbo(phy_struct,
                           phy_struct->dlsch_rx_e_bits[cb],
                           phy_struct->dlsch_N_e_bits[cb],
                           phy_struct->dlsch_tx_d_bits,
                           N_d_bits/3,
                           N_codeblocks,
                           tx_mode,
                           N_soft,
                           M_dl_harq,
                           LIBLTE_PHY_CHAN_TYPE_DLSCH,
                           rv_idx,
                           phy_struct->dlsch_rx_d_bits,
                           &N_d_bits);

        // Determine c_bits
        turbo_decode(phy_struct,
                     phy_struct->dlsch_rx_d_bits,
                     N_d_bits,
                     N_fill_bits,
                     phy_struct->dlsch_c_bits[cb],
                     &phy_struct->dlsch_N_c_bits[cb]);
    }

    // Determine b_bits
    code_block_desegmentation(phy_struct->dlsch_c_bits[0],
                              phy_struct->dlsch_N_c_bits,
                              6144,
                              tbs,
                              phy_struct->dlsch_b_bits,
                              N_b_bits);

    // Recover a_bits and p_bits
    a_bits = &phy_struct->dlsch_b_bits[0];
    p_bits = &phy_struct->dlsch_b_bits[tbs];

    // Calculate p_bits
    calc_crc(a_bits, tbs, CRC24A, calc_p_bits, 24);

    // Check CRC
    ber = 0;
    for(i=0; i<24; i++)
    {
        ber += p_bits[i] ^ calc_p_bits[i];
    }
    if(ber == 0)
    {
        for(i=0; i<tbs; i++)
        {
            out_bits[i] = a_bits[i];
        }
        *N_out_bits = tbs;
        err         = LIBLTE_SUCCESS;
    }

    return(err);
}

/*********************************************************************
    Name: dci_channel_encode

    Description: Channel encodes the Downlink Control Information
                 channel

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.3.3
*********************************************************************/
void dci_channel_encode(LIBLTE_PHY_STRUCT *phy_struct,
                        uint8             *in_bits,
                        uint32             N_in_bits,
                        uint16             rnti,
                        uint8              ue_ant,
                        uint8             *out_bits,
                        uint32            *N_out_bits)
{
    uint32 i;
    uint32 N_d_bits;
    uint32 g[3] = {0133, 0171, 0165}; // Numbers are in octal
    uint8  x_rnti_bits[16];
    uint8  x_as_bits[16];
    uint8  p_bits[16];

    // Convert RNTI to bit array
    for(i=0; i<16; i++)
    {
        x_rnti_bits[i] = (rnti >> (15-i)) & 1;
    }

    // Construct UE antenna mask
    memset(x_as_bits, 0, sizeof(uint8)*16);
    if(ue_ant == 1)
    {
        x_as_bits[15] = 1;
    }

    // Calculate p_bits
    calc_crc(in_bits, N_in_bits, CRC16, p_bits, 16);

    // Mask p_bits
    for(i=0; i<16; i++)
    {
        p_bits[i] ^= x_rnti_bits[i] ^ x_as_bits[i];
    }

    // Construct c_bits
    for(i=0; i<N_in_bits; i++)
    {
        phy_struct->dci_c_bits[i] = in_bits[i];
    }
    for(i=0; i<16; i++)
    {
        phy_struct->dci_c_bits[N_in_bits+i] = p_bits[i];
    }

    // Determine d_bits
    conv_encode(phy_struct,
                phy_struct->dci_c_bits,
                N_in_bits+16,
                7,
                3,
                g,
                true,
                phy_struct->dci_tx_d_bits,
                &N_d_bits);

    // Determine e_bits
    // Always use 576 as the number of bits can be reduced later
    rate_match_conv(phy_struct, phy_struct->dci_tx_d_bits, N_d_bits, 576, out_bits);
    *N_out_bits = 576;
}

/*********************************************************************
    Name: dci_channel_decode

    Description: Channel decodes the Downlink Control Information
                 channel

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.3.3
*********************************************************************/
LIBLTE_ERROR_ENUM dci_channel_decode(LIBLTE_PHY_STRUCT *phy_struct,
                                     float             *in_bits,
                                     uint32             N_in_bits,
                                     uint16             rnti,
                                     uint8              ue_ant,
                                     uint8             *out_bits,
                                     uint32             N_out_bits)
{
    LIBLTE_ERROR_ENUM  err = LIBLTE_ERROR_INVALID_CRC;
    uint32             i;
    uint32             N_d_bits;
    uint32             N_c_bits;
    uint32             ber;
    uint32             g[3] = {0133, 0171, 0165}; // Numbers are in octal
    uint8              x_rnti_bits[16];
    uint8              x_as_bits[16];
    uint8             *a_bits;
    uint8             *p_bits;
    uint8              calc_p_bits[16];

    // Convert RNTI to bit array
    for(i=0; i<16; i++)
    {
        x_rnti_bits[i] = (rnti >> (15-i)) & 1;
    }

    // Construct UE antenna mask
    memset(x_as_bits, 0, sizeof(uint8)*16);
    if(ue_ant == 1)
    {
        x_as_bits[15] = 1;
    }

    // Rate unmatch to get the d_bits
    rate_unmatch_conv(phy_struct,
                      in_bits,
                      N_in_bits,
                      N_out_bits+16,
                      phy_struct->dci_rx_d_bits,
                      &N_d_bits);

    // Viterbi decode the d_bits to get the c_bits
    viterbi_decode(phy_struct,
                   phy_struct->dci_rx_d_bits,
                   N_d_bits,
                   7,
                   3,
                   g,
                   phy_struct->dci_c_bits,
                   &N_c_bits);

    // Recover a_bits and p_bits
    a_bits = &phy_struct->dci_c_bits[0];
    p_bits = &phy_struct->dci_c_bits[N_out_bits];

    // Calculate p_bits
    calc_crc(a_bits, N_out_bits, CRC16, calc_p_bits, 16);

    // Check CRC
    ber = 0;
    for(i=0; i<16; i++)
    {
        ber += p_bits[i] ^ (calc_p_bits[i] ^ x_rnti_bits[i] ^ x_as_bits[i]);
    }
    if(ber == 0)
    {
        for(i=0; i<N_out_bits; i++)
        {
            out_bits[i] = a_bits[i];
        }
        err = LIBLTE_SUCCESS;
    }

    return(err);
}

/*********************************************************************
    Name: dci_1a_unpack

    Description: Unpacks all of the fields from the Downlink Control
                 Information format 1A

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.3.3.1.3
                        3GPP TS 36.213 v10.3.0 section 7.1.6.3
                        3GPP TS 36.213 v10.3.0 section 7.1.7

    Notes: Currently only handles SI-RNTI or P-RNTI, and localized
           virtual resource blocks
*********************************************************************/
void dci_1a_unpack(uint8                           *in_bits,
                   uint32                           N_in_bits,
                   LIBLTE_PHY_DCI_CA_PRESENCE_ENUM  ca_presence,
                   uint16                           rnti,
                   uint32                           N_rb_dl,
                   uint8                            N_ant,
                   LIBLTE_PHY_ALLOCATION_STRUCT    *alloc)
{
    uint32  RB_start = 0;
    uint32  RIV;
    uint32  RIV_length;
    uint32  i;
    uint32  j;
    uint32  ca_ind;
    uint32  N_prb_1a;
    uint32  tpc;
    uint32  dci_0_1a_flag;
    uint32  loc_or_dist;
    uint32  mcs;
    uint32  harq_process;
    uint32  new_data_ind;
    uint8  *dci = in_bits;

    // Carrier indicator
    if(LIBLTE_PHY_DCI_CA_PRESENT == ca_presence)
    {
        ca_ind = phy_bits_2_value(&dci, 3);
        printf("WARNING: Not handling carrier indicator\n");
    }

    // Check DCI 0/1A flag 3GPP TS 36.212 v10.1.0 section 5.3.3.1.3
    dci_0_1a_flag = phy_bits_2_value(&dci, 1);
    if(0 == dci_0_1a_flag)
    {
        printf("ERROR: DCI 1A flagged as DCI 0\n");
        return;
    }

    if(LIBLTE_PHY_SI_RNTI == rnti ||
       LIBLTE_PHY_P_RNTI  == rnti)
    {
        // Determine if RIV uses local or distributed VRBs
        loc_or_dist = phy_bits_2_value(&dci, 1);

        // Find the RIV that was sent 3GPP TS 36.213 v10.3.0 section 7.1.6.3
        RIV_length = (uint32)ceilf(logf(N_rb_dl*(N_rb_dl+1)/2)/logf(2));
        RIV        = phy_bits_2_value(&dci, RIV_length);
        for(i=0; i<N_rb_dl; i++)
        {
            for(j=0; j<(N_rb_dl-i); j++)
            {
                if((i-1) <= (N_rb_dl/2))
                {
                    if(RIV == (N_rb_dl*(i-1)+j))
                    {
                        alloc->N_prb = i;
                        RB_start     = j;
                    }
                }else{
                    if(RIV == (N_rb_dl*(N_rb_dl-i+1)+(N_rb_dl-1-j)))
                    {
                        alloc->N_prb = i;
                        RB_start     = j;
                    }
                }
            }
        }

        // Extract the rest of the fields
        mcs           = phy_bits_2_value(&dci, 5);
        harq_process  = phy_bits_2_value(&dci, 3);
        new_data_ind  = phy_bits_2_value(&dci, 1);
        alloc->rv_idx = phy_bits_2_value(&dci, 2);
        tpc           = phy_bits_2_value(&dci, 2);

        // Parse the data
        if((tpc % 2) == 0)
        {
            N_prb_1a = 2;
        }else{
            N_prb_1a = 3;
        }
        if(loc_or_dist == 1)
        {
            // FIXME: Figure out gapping
            // FIXME: Convert to localized blocks
        }else{
            // Convert allocation into array of prbs
            for(i=0; i<alloc->N_prb; i++)
            {
                alloc->prb[i] = RB_start + i;
            }
        }

        // Fill in the allocation structure 3GPP TS 36.213 v10.3.0 section 7.1.7
        alloc->mod_type       = LIBLTE_PHY_MODULATION_TYPE_QPSK;
        alloc->pre_coder_type = LIBLTE_PHY_PRE_CODER_TYPE_TX_DIVERSITY;
        if(N_ant == 1)
        {
            alloc->tx_mode = 1;
        }else{
            alloc->tx_mode = 2;
        }
        alloc->N_codewords = 1;
        alloc->tbs         = TBS_71721[mcs][N_prb_1a-1];
        alloc->rnti        = rnti;
    }else{
        printf("ERROR: Not handling DCI 1As for C-RNTI\n");
    }
}

/*********************************************************************
    Name: cfi_channel_encode

    Description: Channel encodes the Control Format Indicator channel

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.3.4
*********************************************************************/
void cfi_channel_encode(LIBLTE_PHY_STRUCT *phy_struct,
                        uint32             cfi,
                        uint8             *out_bits,
                        uint32            *N_out_bits)
{
    uint32  i;
    uint8  *cfi_bits;

    *N_out_bits = 32;
    if(1 == cfi)
    {
        cfi_bits = CFI_BITS_1;
    }else if(2 == cfi){
        cfi_bits = CFI_BITS_2;
    }else if(3 == cfi){
        cfi_bits = CFI_BITS_3;
    }else{
        cfi_bits = CFI_BITS_4;
    }
    for(i=0; i<*N_out_bits; i++)
    {
        out_bits[i] = cfi_bits[i];
    }
}

/*********************************************************************
    Name: cfi_channel_decode

    Description: Channel decodes the Control Format Indicator channel

    Document Reference: 3GPP TS 36.212 v10.1.0 section 5.3.4
*********************************************************************/
LIBLTE_ERROR_ENUM cfi_channel_decode(LIBLTE_PHY_STRUCT *phy_struct,
                                     float             *in_bits,
                                     uint32             N_in_bits,
                                     uint32            *cfi)
{
    LIBLTE_ERROR_ENUM err = LIBLTE_ERROR_INVALID_CRC;
    uint32            i;
    uint32            ber_1 = 0;
    uint32            ber_2 = 0;
    uint32            ber_3 = 0;
    uint32            ber_4 = 0;
    uint8             in_bit;

    // Calculate the number of bit errors for each CFI
    for(i=0; i<N_in_bits; i++)
    {
        // Convert from soft NRZ to hard bit
        if(in_bits[i] >= 0)
        {
            in_bit = 0;
        }else{
            in_bit = 1;
        }

        if(CFI_BITS_1[i] != in_bit)
        {
            ber_1++;
        }
        if(CFI_BITS_2[i] != in_bit)
        {
            ber_2++;
        }
        if(CFI_BITS_3[i] != in_bit)
        {
            ber_3++;
        }
        if(CFI_BITS_4[i] != in_bit)
        {
            ber_4++;
        }
    }

    // Find the CFI with no bit errors
    if(ber_1 == 0)
    {
        *cfi = 1;
        err  = LIBLTE_SUCCESS;
    }
    if(ber_2 == 0)
    {
        *cfi = 2;
        err  = LIBLTE_SUCCESS;
    }
    if(ber_3 == 0)
    {
        *cfi = 3;
        err  = LIBLTE_SUCCESS;
    }
    if(ber_4 == 0)
    {
        *cfi = 4;
        err  = LIBLTE_SUCCESS;
    }

    return(err);
}

/*********************************************************************
    Name: get_soft_decision

    Description: Determines the magnitude of the soft decision

    Document Reference: N/A
*********************************************************************/
float get_soft_decision(float p1_re,
                        float p1_im,
                        float p2_re,
                        float p2_im,
                        float max_dist)
{
    float diff_re;
    float diff_im;
    float dist;

    diff_re = p1_re - p2_re;
    diff_im = p1_im - p2_im;
    dist    = sqrt(diff_re*diff_re + diff_im*diff_im);

    if(dist >= max_dist)
    {
        dist = max_dist - (max_dist/120);
    }

    return(max_dist - dist);
}

/*********************************************************************
    Name: phy_bits_2_value

    Description: Converts a bit string to a value

    Document Reference: N/A
*********************************************************************/
uint32 phy_bits_2_value(uint8  **bits,
                        uint32   N_bits)
{
    uint32 value = 0;
    uint32 i;

    for(i=0; i<N_bits; i++)
    {
        value |= (*bits)[i] << (N_bits-i-1);
    }
    *bits += N_bits;

    return(value);
}
